## 双飞翼布局

最常见的双飞翼布局实现方法。

需求
双飞翼布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。

双飞翼布局与圣杯布局的不同之处，圣杯布局的的左中右三列容器，中间middle多了一个子容器存在，通过控制 middle 的子容器的 margin 或者 padding 空出左右两列的宽度。

关键点
双飞翼布局的关键点是通过 margin-left 属性将左右两列放置到准确的位置，通过控制 middle 的子容器的 margin 或者 padding 空出左右两列的宽度
双飞翼布局的关键点父元素不需要设置 padding
双飞翼布局的关键点 margin-left 取值为百分比时，是以其父元素的宽度为基准的

HTML：

```pug
// pug 模板引擎
div.g-container
    div.g-middle 
        div.g-middle-inner middle-inner 
    div.g-left left
    div.g-right right
```

SCSS：

```scss
.g-container {
    position: relative;
    height: 100vh;
    min-width: 400px;
    
    & > div {
        height: 100vh;
        float: left;
        text-align: center;
        color: #fff;
        line-height: 100vh;
        font-size: 3vw;
    }
}

.g-middle {
    position: relative;
    width: 100%;
    background: #cc6630;
    
    .g-middle-inner {
        margin: 0 200px;
    }
}

.g-left {
    position: relative;
    width: 200px;
    background: #ffcc00;
    margin-left: -100%;
}

.g-right {
    position: relative;
    width: 200px;
    background: pink;
    margin-left: -200px;
}
```

## grid 布局配合 clip-path 实现 GTA5 封面

利用 grid 布局配合 clip-path 实现 GTA5 封面。

### 关键点

- grid 实现不规则的网格布局
- clip-path 控制每个格子的形状

关于本效果的详细描述，你可以查看这篇文章：[新时代创意布局不完全指南](https://github.com/chokcoco/iCSS/issues/70)

HTML：

```
<div class="parent">
  <div class="child" >
    <img src="https://i.pinimg.com/originals/0d/67/72/0d677237854ed19dcfe69f0f9a4065ee.jpg" alt="">
  </div>
  <div class="child">
    <img src="https://i.pinimg.com/736x/26/db/84/26db84b2bf348f79792f7c5f0f9bd5ef.jpg" alt="">
  </div>
  <div class="child">
    <img src="https://i.pinimg.com/736x/45/0d/1c/450d1c87ce61bc0c2429701ed3ea631a.jpg" alt="">
  </div>
  <div class="child">
    <img src="https://i.pinimg.com/564x/94/76/dd/9476dd3d346a3d697362da94b9aa2dc2.jpg" alt="">
  </div>
  <div class="child">
    <img src="https://www.sitedogta.com.br/gta5/imagens/personagens/Trevor%20GTA%20V.JPG" alt="">
  </div>
  <div class="child">
    <img src="https://i.pinimg.com/564x/3b/3b/56/3b3b56745376625aa66d5943b3db0275.jpg" alt="">
  </div>
  <div class="child">
    <img src="https://i.pinimg.com/originals/c8/9c/6b/c89c6b8f2165cfbe5ecccfebace1042d.jpg" alt="">
  </div>
  <div class="child">
    <img src="https://i.pinimg.com/736x/ea/e7/b5/eae7b513060702e86bdd51d4d5cfc5ae.jpg" alt="">
  </div>
  <div class="child">
    <img src="https://cdn.hipwallpaper.com/i/94/92/Fk0l6I.jpg" alt="">
  </div>
</div>  
```

SCSS：

```scss
*{
  box-sizing: border-box;
}
body{
  padding:0; 
  margin: 0;
  background: #23232a;
}
img{
  width:100%;
  height: 100%;
  object-fit: cover;
  object-position: 40% 0;
}

.parent{
  padding: .8rem;
  background: black;
  height: 95vh;
  min-height: 500px;
  width: 100%;
  max-width: 600px;
  margin: auto;
  margin-top: 2.5vh;
  border: 1px solid #c9b473;
  overflow: hidden;
  display: grid;

  grid-template-columns: 1fr .7fr .3fr 1fr;
  grid-template-rows: 20% 40% 20% 20%;
  grid-template-areas: 'one two two three'
    'four five five five'
    'six five five five'
    'six seven eight eight';
}


// For clipping I used mozilla's inspect element. 
.child{

  &:nth-child(1),
  &:nth-child(2),
  &:nth-child(3){
    img{
      width:120%;
      height: 120%;
    }
  }
  &:first-child{
    grid-area: one;
    clip-path: polygon(0% 0%, 93.24% 0%, 105.04% 110.16%, 0% 90%);
  }
  &:nth-child(2){
    grid-area: two;
    clip-path: polygon(0% 0%, 108.28% 0%, 96.45% 110.13%, 10.55% 110.93%);
  }
  &:nth-child(3){
    grid-area: three;
    clip-path:polygon(15.05% 0%, 100% 0%, 99.35% 91.7%, 3.08% 108.48%);
  }
  &:nth-child(4){
    grid-area: four;
    clip-path: polygon(0% -0.85%, 106.34% 9.98%, 121.32% 65.63%, 99.66% 109.89%, 1.86% 124.41%);

    img{
      width: 135%;
      height: 135%;
    }
  }
  &:nth-child(5){
    grid-area: five;
    clip-path: polygon(6.4% 6.48%, 47.24% 5.89%, 100% 0%, 98.41% 96.85%, 53.37% 100%, 53% 63.21%, 3.23% 73.02%, 14.30% 44.04%);
  }
  &:nth-child(6){
    grid-area: six;
    clip-path:  polygon(2.14% 29.3%, 99.34% 15.42%, 98.14% 100.82%, 1.57% 101.2%);
  }
  &:nth-child(7){
    grid-area: seven;
    clip-path: polygon(7.92% 33.47%, 96.31% 23.39%, 95.38% 100%, 5.30% 100.85%);
  }
  &:nth-child(8){
    grid-area: eight;
    clip-path: polygon(2.5% 22.35%, 100% 0%, 100% 100%, 1.55% 100%);
  }
  &:nth-child(9){
    grid-row-start: 3;
    grid-row-end: 4;
    grid-column-start: 2;
    grid-column-end: 4; 

    clip-path:polygon(5.94% 28.66%, 100.61% -0.67%, 101.1% 108.57%, 5.4% 126.28%);

    img{
      object-position: 30% 50%;
      height: 135%;
    }
  }
}
```

## flex 实现圣杯布局

使用 flex 实现的圣杯布局。

### 需求

圣杯布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。

圣杯布局与双飞翼布局的不同之处，圣杯布局的的左中右三列容器没有多余子容器存在，通过控制父元素的 padding 空出左右两列的宽度。

### 关键点

- 圣杯布局的关键点是通过 margin-left 与 left 属性将左右两列放置到准确的位置
- 圣杯布局的关键点父元素需要设置 padding
- 圣杯布局的关键点 margin-left 取值为百分比时，是以其父元素的宽度为基准的

HTML：

```pug
// pug 模板引擎
div.g-container
    div.g-middle middle
    div.g-left left
    div.g-right right
```

SCSS：

```scss
.g-container {
    position: relative;
    height: 100vh;
    min-width: 400px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    
    & > div {
        height: 100vh;
        text-align: center;
        color: #fff;
        line-height: 100vh;
        font-size: 3vw;
    }
}

.g-middle {
    order: 2;
    flex: auto 1 0 ;
    background: #cc6630;
}

.g-left {
    order: 1;
    flex: 200px 0 0;
    background: #ffcc00;
}

.g-right {
    order: 3;
    flex: 200px 0 0;
    background: pink;
}
```

## 圣杯布局

最常见的圣杯布局实现方法。

### 需求

圣杯布局左中右三列布局，渲染顺序中间列书写在前保证提前渲染，左右两列定宽，中间列自适应剩余宽度。

圣杯布局与双飞翼布局的不同之处，圣杯布局的的左中右三列容器没有多余子容器存在，通过控制父元素的 padding 空出左右两列的宽度。

### 关键点

- 圣杯布局的关键点是通过 margin-left 与 left 属性将左右两列放置到准确的位置
- 圣杯布局的关键点父元素需要设置 padding
- 圣杯布局的关键点 margin-left 取值为百分比时，是以其父元素的宽度为基准的

HTML：

```pug
// pug 模板引擎
div.g-container
    div.g-middle middle
    div.g-left left
    div.g-right right
```

SCSS：

```scss
.g-container {
    // overflow: hidden;
    position: relative;
    height: 100vh;
    padding: 0 200px;
    min-width: 400px;
    
    & > div {
        height: 100vh;
        float: left;
        text-align: center;
        color: #fff;
        line-height: 100vh;
        font-size: 3vw;
    }
}

.g-middle {
    position: relative;
    width: 100%;
    background: #cc6630;
}

.g-left {
    position: relative;
    width: 200px;
    background: #ffcc00;
    margin-left: -100%;
    left: -200px;
}

.g-right {
    position: relative;
    width: 200px;
    background: pink;
    margin-left: -200px;
    right: -200px;
}
```

## 6种实现多列等高的方法

多种实现多列等高的方法

### 需求

多列等高，要求左右两列高度自适应且一样，分别设置不同背景色

### 实现

1. `padding + margin + overflow` 实现多列等高效果，兼容性好
2. border实现多列等高，左边框宽度为200px，左列浮动，伪元素清除浮动
3. 父元素线性渐变背景色实现多列等高（同理各种颜色障眼法）
4. display：flex实现多列等高
5. display：grid实现多列等高
6. display:table-cell 实现多列等高

1. HTML：

```html
<div class="g-container">
    <div class="g-xxx">
        <div class="g-left">
            content<br/>
        </div>
        <div class="g-right">
            content<br/>
            content<br/>
            content<br/>
            content<br/>
        </div>
    </div>
</div>
```

SCSS：

```scss
h2 {
    text-align: center;
    line-height: 60px;
    font-size: 20px;
    background: #00bcd4;
    color: #fff;
}

.g-container {
    width: 1000px;
    margin: 0 auto;
    line-height: 2;
    color: #fff;
    
    & > div {
        margin-bottom: 50px;
    }
}



.g-padmar {
    position: relative;
    overflow: hidden;

    .g-left {
        float: left;
        width: 200px;
        background: #4caf50;
        padding-bottom:9999px;
        margin-bottom:-9999px;
    }
    
    .g-right {
        float: left;
        width: 800px;
        background: #99afe0;
        padding-bottom: 9999px;
        margin-bottom: -9999px;
    }
}

.g-border {
    position: relative;
    width: 800px;
    border-left: 200px solid #4caf50;
    background: #99afe0;
    
    &::after {
        content: ".";
        display:block;
        height: 0;
        clear: both;
    }
    
    .g-right {
        width: 800px;
    }
    
    .g-left {
        float: left;
        width: 200px;
        margin-left: -200px;
    }
}

.g-lineargradient {
    background: linear-gradient(90deg, #4caf50 0, #4caf50 20%, #99afe0 20%, #99afe0);
    overflow: hidden;
    
    .g-left {
        float: left;
        width: 200px;
    }
    
    .g-right {
        float: left;
        width: 800px;
    }
}

.g-flex {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: stretch;
    
    .g-left {
        flex: 200px 0 0 ;
        background: #4caf50;
    }
    
    .g-right {
        flex: auto 1 0;
        background: #99afe0;
    } 
}

.g-grid {
    display: grid;
    // align-items: stretch; 默认值
    grid-template-columns: 200px auto;
    
    .g-left {
        background: #4caf50;
    }
    
    .g-right {
        background: #99afe0;
    } 
}

.g-table {
    overflow:hidden;
    display:table;
    
    .g-left {
        width: 200px;
        display: table-cell;
        background: #4caf50;
    }
    
    .g-right {
        width: 800px;
        display: table-cell;
        background: #99afe0;
    } 
}
```

## 多方案实现跨行或跨列布局

多方案实现多方案实现跨行或跨列布局

HTML：

```pug
// pug 模板引擎
div.g-container

    h2 float 实现
    div.g-float
        - for(var i=0; i<3; i++)
            div.g-item #{i}
            
    h2 flex 实现
    div.g-flex
        - for(var i=0; i<3; i++)
            div.g-item #{i}
            
    h2 grid 实现
    div.g-grid
        - for(var i=0; i<3; i++)
            div.g-item #{i}
```

SCSS：

```scss
.g-container {
    margin: 20px auto;
    width: 400px;
}

.g-item {
    width: 190px;
    height: 190px;
    box-sizing: border-box;
    border: 1px solid #666;
    border-radius: 10px;
    line-height: 190px;
    font-size: 32px;
    text-align: center;
    cursor:pointer;
    margin: 5px;
    transition: .1s all;
}

.g-float {
    overflow: hidden;
    
    .g-item {
        float: left;
    }
    
    .g-item:first-child {
        height: 390px;
    }

    .g-item:first-child:hover {
        height: 190px;
        width: 390px;
    }
}

h2 {
    font-size: 28px;
    text-align: center;
    margin: 30px auto
}


.g-flex {
    width: 400px;
    height: 400px;
    overflow: hidden;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    flex-direction: column;
    
    .g-item:first-child {
        height: 390px;
    }
}

.g-flex:hover {
    flex-direction: row;

    .g-item:first-child {
        height: 190px;
        width: 390px;
    }
}

.g-grid {
    width: 400px;
    height: 400px;
    overflow: hidden;
    display: grid;
    grid-template-columns: repeat(2, 50%);
    grid-template-rows: repeat(2, 50%);
    
    .g-item {
        width: unset;
        height: unset;
    }
    
    .g-item:first-child {
        grid-row: 1 / 3;
        grid-column: 1 / 2;
    }
}

.g-grid:hover {
    .g-item:first-child {
        grid-row: 1 / 2;
        grid-column: 1 / 3;
    }
}
```

## 多种方案实现单列等宽，其他多列自适应均匀布局

多种方案实现单列等宽，其他多列自适应均匀布局

### 需求

共4列，首列宽度固定为200px，其余3列均分剩余宽度，每列间距10px

### 实现

- `display: grid` 实现
- `display: flex` 实现
- `position: aboslute + float` 实现
- `position: aboslute + float +非calc实现`

### 难点

对于不使用 flex、grid 以及 css3 特性 calc 而言，实现多列自适应均匀分布只能是百分比。

百分比均分后间距的均分，这里参考了 bootstrap 的实现方式。

HTML：

```pug
// pug 模板引擎

div.g-grid
    - for(var i=0; i<4; i++)   
        div.g-item #{i}
        
div.g-flex
    - for(var i=0; i<4; i++)   
        div.g-item #{i}
        
div.g-position
    - for(var i=0; i<4; i++)   
        div.g-item #{i}

div.g-justify  
    div.g-left 0
    div.g-col
        div.g-row
            - for(var i=1; i<4; i++) 
                div.g-item-box
                    div.g-item #{i}
```

SCSS：

```scss
h2 {
    font-size: 28px;
    text-align: center;
    color: #fff;
    background: #009688;
    line-height: 2;
}

.g-left,
.g-item {
    background: #3f51b5;
    line-height: 200px;
    color: #fff;
    text-align: center;
    font-size: 24px;
}

.g-grid {
    height: 200px;
    background: #ff9800;
    display: grid;
    grid-template-columns: 200px repeat(3, 1fr);
    grid-column-gap: 10px;
    margin-bottom: 20px;
}

.g-flex {
    height: 200px;
    background: #ff9800;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: space-between;
    margin-bottom: 20px;

    .g-item {
        flex: 0 1 calc((100% - 200px - 30px) / 3);
    }
    
    .g-item:first-child {
        flex: 0 1 200px;
    }
}

.g-position {
    position: relative;
    height: 200px;
    background: #ff9800;
    margin-bottom: 20px;

    .g-item {
        float: left;
        width: calc((100% - 200px - 30px) / 3);
        margin-left: 10px;
    }
    
    .g-item:nth-child(2) {
        float: left;
        width: calc((100% - 200px - 30px) / 3);
        margin-left: 210px;
    }
    
    .g-item:first-child {
        position: absolute;
        top: 0;
        left: 0;
        width: 200px;
        height: 200px;
        float: unset;
        margin-left: unset;
    }
}

.g-justify {
    position: relative;
    height: 200px;
    background: #ff9800;
    margin-bottom: 20px;

    .g-col,
    .g-row,
    .g-item-box {
        box-sizing: border-box;
    }
    
    .g-left {
        position: absolute;
        top: 0;
        left: 0;
        width: 200px;
        height: 200px;
    }
    
    .g-row {
        margin-right: -5px;
        margin-left: -5px;
    }
    
    .g-col {
        position: absolute;
        top: 0;
        left: 210px;
        right: 0;
        height: 200px;
        overflow: hidden;
        
        &:before,
        &:after {
          display: table;
          content: " ";
        }
        
        &:after {
          clear: both;
        }
        
        .g-item-box {
            position: relative;
            float: left;
            width: 33.33%;
            padding-left: 5px;
            padding-right: 5px;
        }
    }
}
```

## 使用 margin auto 实现 flex 下的 align-self: flex-end

使用 margin auto 实现 flex 下的 align-self: flex-end

### 难点

核心点在于使用了 FFC/GFC 使 margin: auto 可以自动分配剩余空间。

在 `dispaly: flex` 下：

- Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.

> [CSS Flexible Box Layout Module Level 1 -- 8.1. Aligning with auto margins](https://www.w3.org/TR/2018/CR-css-flexbox-1-20181119/#auto-margins)

简单翻译一下，大意是在 **flex 格式化上下文**中，设置了 `margin: auto` 的元素，在通过 `justify-content` 和 `align-self` 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去

这里，很重要的一点是，margin auto 的生效不仅是水平方向，垂直方向也会自动去分配这个剩余空间。

HTML：

```HTML
<ul class="g-flex">
    <li>liA</li>
    <li>liB</li>
    <li>liC</li>
    <li>liD</li>
    <li>liE</li>
</ul>
```

SCSS：

```scss
.g-flex {
    height: 200px;
    box-sizing: border-box;
    background: #037d65;
    
    display: flex;
    // display: flex-inline;
    // justify-content: space-around;
}

li {
    // align-self: center;
    width: 100px;
    text-align: center;
    font-size: 18px;
    color: #fff;
    
    margin: auto;
    margin-bottom: 0;
    margin-top: auto;
}

li:nth-child(1) {
    height: 100px;
    background: #336699;
}

li:nth-child(2) {
    height: 120px;
    background: #669933;
}

li:nth-child(3) {
    height: 140px;
    background: #996633;
}

li:nth-child(4) {
    height: 160px;
    background: #229955;
}

li:nth-child(5) {
    height: 180px;
    background: #199652;
}
```

## 使用 margin auto 实现 flex 下的 justify-content: space-between

使用 margin auto 实现 flex 下的 justify-content: space-between

### 难点

核心点在于使用了 FFC/GFC 使 margin: auto 可以自动分配剩余空间。

在 `dispaly: flex` 下：

- Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.

> [CSS Flexible Box Layout Module Level 1 -- 8.1. Aligning with auto margins](https://www.w3.org/TR/2018/CR-css-flexbox-1-20181119/#auto-margins)

简单翻译一下，大意是在 **flex 格式化上下文**中，设置了 `margin: auto` 的元素，在通过 `justify-content` 和 `align-self` 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去

这里，很重要的一点是，margin auto 的生效不仅是水平方向，垂直方向也会自动去分配这个剩余空间。

HTML：

```HTML
<ul class="g-flex">
    <li>liA</li>
    <li>liB</li>
    <li>liC</li>
    <li>liD</li>
    <li>liE</li>
</ul>
```

SCSS：

```scss
.g-flex {
    height: 100px;
    margin-bottom: 100px;
    box-sizing: border-box;
    background: #037d65;
    
    display: flex;
    // justify-content: space-between;
}

li {
    width: 100px;
    line-height: 100px;
    text-align: center;
    font-size: 18px;
    color: #fff;
    
    margin: auto;
}

li:first-child {
    margin-left: 0;
}

li:last-child {
    margin-right: 0;
}
```

## Box-shadow实现圆环进度条动画

Box-shadow实现圆环进度条动画。这个真的算是奇技淫巧。

### 关键点

- 圆环进度条的移动本质上是阴影顺序延时移动的结果。

HTML：

```html
<div class="container">
    <div class="shadow">Hover Me</div>
</div>
```

SCSS：

```scss
$color: #e91e63;

body {
    background: #000;
}

.container {
    position: relative;
    overflow: hidden;
    width: 124px;
    height: 124px;
    overflow: hidden;
    margin: 100px auto;
    border-radius: 50%;
}

.shadow {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 120px;
    height: 120px;
    line-height: 120px;
    border-radius: 50%;
    color: #fff;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 60px -60px 0 2px $color, -60px -60px 0 2px $color,
        -60px 60px 0 2px $color, 60px 60px 0 2px $color;
    text-align: center;
    
    &:hover {
        animation: border .5s ease forwards;
    }
}

@keyframes border{
  0% {
    box-shadow: 60px -60px 0 2px $color, -60px -60px 0 2px $color, -60px 60px 0 2px $color, 60px 60px 0 2px $color, 0 0 0 2px transparent;
  }
  25% {
    box-shadow: 0 -125px 0 2px $color, -60px -60px 0 2px $color, -60px 60px 0 2px $color, 60px 60px 0 2px $color, 0 0 0 2px #fff;
  }
  50% {
    box-shadow: 0 -125px 0 2px $color, -125px 0px 0 2px $color, -60px 60px 0 2px $color, 60px 60px 0 2px $color, 0 0 0 2px #fff;
  }
  75% {
    box-shadow: 0 -125px 0 2px $color, -125px 0px 0 2px $color, 0px 125px 0 2px $color, 60px 60px 0 2px $color, 0 0 0 2px #fff;
  }
  100% {
    box-shadow: 0 -125px 0 2px $color, -125px 0px 0 2px $color, 0px 125px 0 2px $color, 120px 40px 0 2px $color, 0 0 0 2px #fff;
  } 
}
```

## 使用box-shadow/渐变实现内切角

### 关键点

- 阴影实现的关键点在于使用伪元素绝对定位在容器的一角，元素本身透明，阴影扩散开形成内切圆角效果
- 阴影实现缺点，单个标签最多只能是2个内切圆角
- 径向渐变实现内切圆角可以是4边

HTML：

```html
<div class="shadow">使用阴影的扩散半径实现内切圆角</div>
<div class="shadow2">阴影实现缺点，单个标签最多是2边</div>
<div class="linear">使用径向渐变实现内切圆角</div>
<div class="linear2">径向渐变实现内切圆角可以是4边</div>
```

SCSS：

```scss
body {
    background: linear-gradient(90deg, #fff, #bbb);
}

div {
    position: relative;
    width: 20vw;
    height: 8vw;
    margin: 1vw auto;
    border-radius: 1vmin;
    // background: #e91e63;
    overflow: hidden;
    line-height: 8vw;
    color: #fff;
    text-align: center;
}

.shadow {
    
    &::before {
        position: absolute;
        content: "";
        top: -2vw;
        left: -2vw;
        width: 4vw;
        height: 4vw;
        border-radius: 50%;
        box-shadow: 0 0 0 25vw #e91e63; 
        z-index: -1;
        animation: shadowmove 10s infinite;
    }
}

.shadow2 {
        &::before {
        position: absolute;
        content: "";
        top: -2vw;
        left: -2vw;
        width: 4vw;
        height: 4vw;
        border-radius: 50%;
        box-shadow: 0 0 0 15vw #e91e63; 
        z-index: -1;
    }
    
    &::after {
        position: absolute;
        content: "";
        bottom: -2vw;
        right: -2vw;
        width: 4vw;
        height: 4vw;
        border-radius: 50%;
        box-shadow: 0 0 0 15vw #e91e63; 
        z-index: -1;
    }
}

@keyframes shadowmove {
    0%{
        background: #e91e63; 
        box-shadow: 0 0 0 0 #e91e63; 
    }
    
    10% {
        background: transparent; 
        box-shadow: 0 0 0 0 #e91e63; 
    }
    
    50% {
        background: transparent; 
        box-shadow: 0 0 0 25vw #e91e63; 
    }
}

.linear {
    background-size: 100% 100%;
    background-image: radial-gradient(circle at 0 0, transparent 0, transparent 2vw, #03A9F5 2vw);
    background-repeat: no-repeat;
}

.linear2 {
    background-size: 70% 70%;
    background-image: 
        radial-gradient(circle at 100% 100%, transparent 0, transparent 2vw, #03A9F5 2vw),
        radial-gradient(circle at 0 0, transparent 0, transparent 2vw, #03A9F5 2vw),
        radial-gradient(circle at 100% 0, transparent 0, transparent 2vw, #03A9F5 2vw),
        radial-gradient(circle at 0 100%, transparent 0, transparent 2vw, #03A9F5 2vw);
    background-repeat: no-repeat;
    background-position: right bottom, left top, right top, left bottom;
}
```

## Neon Effect 3D TEXT

利用阴影实现的 3D 氖灯效果。

### 关键点

- 利用 `text-shadow` 叠加多层文字阴影
- 利用 animation 动态改变阴影颜色

HTML：

```
<div class="container">
    <p class="a">CSS 3D</p>
    <p class="b">NEON</p>
    <p class="a">EFFECT</p>
</div>
```

SCSS：

```scss
@import url("https://fonts.googleapis.com/css2?family=Rajdhani:wght@300&display=swap");

html,
body {
    width: 100%;
    height: 100%;
    display: flex;
    font-family: "Rajdhani", sans-serif;
    font-weight: bold;
    background: #000;
}

.container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    margin: auto;
    transform: rotateX(25deg) rotateY(-25deg);
}

p {
    text-align: center;
    display: block;
    font-size: 26vh;
    letter-spacing: 0.1em;
    max-height: 22vh;
}

.a {
    color: #88e;
    text-shadow: 0 0 0.3em rgba(200, 200, 255, 0.3), 0.04em 0.04em 0 #112,
        0.045em 0.045em 0 #88e, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #66c,
        0.14em 0.14em 0 #112, 0.145em 0.145em 0 #44a;
    animation: pulsea 300ms ease infinite alternate;
}

.b {
    color: #f99;
    text-shadow: 0 0 0.3em rgba(255, 100, 200, 0.3), 0.04em 0.04em 0 #112,
        0.045em 0.045em 0 #f99, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #b66,
        0.14em 0.14em 0 #112, 0.145em 0.145em 0 #a44;
    animation: pulseb 300ms ease infinite alternate;
}

@keyframes pulsea {
    0% {
        text-shadow: 0 0 0.3em rgba(200, 200, 255, 0.3), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #88e, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #66c,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #aaf;
    }
    50% {
        text-shadow: 0 0 0.3em rgba(200, 200, 255, 0.3), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #88e, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #aaf,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #44a;
    }
    75% {
        text-shadow: 0 0 0.3em rgba(200, 200, 255, 0.3), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #aaf, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #66c,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #44a;
    }
    100% {
        text-shadow: 0 0 0.3em rgba(200, 200, 255, 0.4), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #88e, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #66c,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #44a;
    }
}

@keyframes pulseb {
    0% {
        text-shadow: 0 0 0.3em rgba(255, 100, 200, 0.3), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #f99, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #b66,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #faa;
    }
    50% {
        text-shadow: 0 0 0.3em rgba(255, 100, 200, 0.3), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #f99, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #faa,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #a44;
    }
    75% {
        text-shadow: 0 0 0.3em rgba(255, 100, 200, 0.3), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #faa, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #b66,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #a44;
    }
    100% {
        text-shadow: 0 0 0.3em rgba(255, 100, 200, 0.3), 0.04em 0.04em 0 #112,
            0.045em 0.045em 0 #f99, 0.09em 0.09em 0 #112, 0.095em 0.095em 0 #b66,
            0.14em 0.14em 0 #112, 0.145em 0.145em 0 #a44;
    }
}
```

## box-shadow实现霓虹氖灯文字效果

### 关键点

- 多重阴影的过渡效果与白色字体的叠加

HTML：

```html
<div>
    <p class="pink">PINK</p>
</div>
<div>
    <p class="orange">Box-Shadow</p>
</div>
<div>
    <p class="yellow">YELLOW</p>
</div>
```

SCSS：

```scss
body {
    background: #111;
    text-align: center;
}

p {
    display: inline;
    font-family: 'Lobster';
    text-align: center;
    font-size: 20vmin;
    line-height: 40vmin;
    color: #fff;
    cursor: pointer;
    
    &:hover {
        color: #fff;
    }
}

.pink {
    filter: brightness(110%);
    text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #fff, 0 0 20px #E91E63, 0 0 35px #E91E63, 0 0 40px #E91E63, 0 0 50px #E91E63, 0 0 75px #E91E63;
    animation: pink 1.5s ease-in-out infinite alternate;
}

.orange {
    color: #ff5722;
}

.orange:hover {
    animation: orange 1.5s ease-in-out infinite alternate;
}

.yellow {
    color: #ffeb3b;
}

.yellow:hover {
    animation: yellow 1.5s ease-in-out infinite alternate;
}

@keyframes pink {
  to {
    text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #E91E63, 0 0 70px #E91E63, 0 0 80px #E91E63, 0 0 100px #E91E63, 0 0 150px #E91E63;
  }
}

@keyframes orange {
    to {
        text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #ff5722, 0 0 70px #ff5722, 0 0 80px #ff5722, 0 0 100px #ff5722, 0 0 150px #ff5722;
        
    }
    from {
        filter: brightness(110%);
        text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #fff, 0 0 20px #ff5722, 0 0 35px #ff5722, 0 0 40px #ff5722, 0 0 50px #ff5722, 0 0 75px #ff5722;
  }
}

@keyframes yellow {
    to {
        text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #ffeb3b, 0 0 70px #ffeb3b, 0 0 80px #ffeb3b, 0 0 100px #ffeb3b, 0 0 150px #ffeb3b;
        
    }
    from {
        filter: brightness(110%);
        text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #fff, 0 0 20px #ffeb3b, 0 0 35px #ffeb3b, 0 0 40px #ffeb3b, 0 0 50px #ffeb3b, 0 0 75px #ffeb3b;
  }
}
```

## 使用 box-shadow 实现半透明遮罩

使用 box-shadow 实现半透明遮罩，在某些特殊场景下能发挥很好的作用

HTML：

```html
<p>背景文字背景文字背景文字背景文字</p>
<div>Hover Me</div>
```

SCSS：

```scss
div {
    position: absolute;
    width: 200px;
    height: 60px;
    line-height: 60px;
    text-align: center;
    border: 1px solid #666;
    cursor: pointer;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    transition: all .1s;
}

div:hover {
    box-shadow: 0 0 0 50vmax rgba(0, 0, 0, .5);
}
```

## 立体投影

CSS 实现立体投影。

### 关键点

- 立体投影的关键点在于利于伪元素生成一个大小与父元素相近的元素，然后对其进行 rotate 以及定位到合适位置，再赋于阴影操作。
- 颜色的运用也很重要，阴影的颜色通常比本身颜色要更深，这里使用 hsl 表示颜色更容易操作，l 控制颜色的明暗度。

HTML：

```html
<div class="g-left"></div>
<div class="g-both"></div>
<div class="g-slide"></div>
```

SCSS：

```scss
div {
    position: relative;
    width: 600px;
    height: 100px;
    margin: 5vmin auto 15vmin;
    background: hsl(48, 100%, 50%);
    border-radius: 20px;
    box-shadow: 0 0 5px 2px hsl(48, 100%, 45%);
}

.g-left::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 5%;
    right: 5%;
    bottom: 0;
    border-radius: 10px;
    background: hsl(48, 100%, 20%);
    transform: translate(0, -15%) rotate(-4deg);
    transform-origin: center center;
    box-shadow: 0 0 20px 15px hsl(48, 100%, 20%);
    z-index: -1;
}

.g-both {
    background: hsl(199, 98%, 48%);
    box-shadow: 0 0 5px 2px hsl(199, 98%, 40%);
}

.g-both::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 5%;
    right: 5%;
    bottom: 15%;
    border-radius: 10px;
    background: hsl(199, 98%, 20%);
    transform: translate(0, -20%) rotate(-4deg);
    transform-origin: center center;
    box-shadow: 0 0 20px 15px hsl(199, 98%, 20%);
    z-index: -1;
}

.g-both::after {
    content: "";
    position: absolute;
    top: 50%;
    left: 5%;
    right: 5%;
    bottom: 15%;
    border-radius: 10px;
    background: hsl(199, 98%, 20%);
    transform: translate(0, -20%) rotate(4deg);
    transform-origin: center center;
    box-shadow: 0 0 20px 15px hsl(199, 98%, 20%);
    z-index: -1;
}

.g-slide {
    background: hsl(150, 62%, 52%);
    box-shadow: 0 0 5px 2px hsl(150, 62%, 40%);
}

.g-slide::before {
    content: "";
    position: absolute;
    top: 15%;
    bottom: 20%;
    left: 90%;
    right: 5%;
    border-radius: 10px;
    background: hsl(150, 62%, 20%);
    transform: translate(105%, 10%) rotate(15deg);
    transform-origin: center center;
    box-shadow: 0 0 10px 7px hsl(150, 62%, 20%);
    z-index: -1;
}

.g-slide::after {
    content: "";
    position: absolute;
    top: 15%;
    bottom: 20%;
    left: 5%;
    right: 90%;
    border-radius: 10px;
    background: hsl(150, 62%, 20%);
    transform: translate(-105%, 10%) rotate(-15deg);
    transform-origin: center center;
    box-shadow: 0 0 10px 7px hsl(150, 62%, 20%);
    z-index: -1;
}
```

## 立体文字阴影

CSS 实现立体文字阴影。

### 关键点

- 立体文字阴影的关键点在于多层 text-shadow 的叠加
- 这里合理运用了 SASS 函数来自动计算多层 text-shadow 的 CSS 代码
- 运用了 Sass 的颜色函数，渐进实现层级阴影颜色
  - fade-out: 改变颜色的透明度，让颜色更加透明
  - desaturate: 改变颜色的饱和度值，让颜色更少的饱和

HTML：

```html
<div>Txt Shadow</div>
<div class="left"> TxT Long Shadow</div>
```

SCSS：

```scss
body {
    background: #03a9f4;
}

@function makelongrightshadow($color) {
    $val: 0px 0px $color;
    @for $i from 1 through 50 {
        $color: fade-out(desaturate($color, 1%), .02);
        $val: #{$val}, #{$i}px #{$i}px #{$color};
    }
    @return $val;
}

@function makelongleftshadow($color) {
    $val: 0px 0px $color;
    @for $i from 1 through 50 {
        $color: fade-out(desaturate($color, 1%), .02);
        $val: #{$val}, -#{$i}px #{$i}px #{$color};
    }
    @return $val;
}

div {
    text-align: center;
    font-size: 20vmin;
    line-height: 45vh;
    text-shadow: makelongrightshadow(hsla(14, 100%, 30%, 1));
    color: hsl(14, 100%, 60%);
}

.left {
    text-shadow: makelongleftshadow(hsla(231, 50%, 30%, 1));
    color: hsl(231, 50%, 60%);
}
```

## 浮雕风格按钮

利用 `box-shadow` 实现浮雕风格的按钮。

### 关键点

- `box-shadow` 与颜色的合理搭配

HTML：

```HTML
<form>
  <div class="segment">
    <h1>Sign up</h1>
  </div>
  <label>
    <input type="text" placeholder="Email Address" />
  </label>
  <label>
    <input type="password" placeholder="Password" />
  </label>
  <button class="red" type="button"><i class="icon ion-md-lock"></i> Log in</button>
  <div class="segment">
    <button class="unit" type="button"><i class="icon ion-md-arrow-back"></i></button>
    <button class="unit" type="button"><i class="icon ion-md-bookmark"></i></button>
    <button class="unit" type="button"><i class="icon ion-md-settings"></i></button>
  </div>
  <div class="input-group">
    <label>
      <input type="text" placeholder="Email Address" />
    </label>
    <button class="unit" type="button"><i class="icon ion-md-search"></i></button>
  </div>
</form>
```

SCSS：

```scss
$ruler: 16px;
$color-red: #ae1100;
$color-bg: #ebecf0;
$color-shadow: #babecc;
$color-white: #fff;

body,
html {
  background-color: $color-bg;
}

body,
p,
input,
select,
textarea,
button {
  font-family: "Montserrat", sans-serif;
  letter-spacing: -0.2px;
  font-size: $ruler;
}

div,
p {
  color: $color-shadow;
  text-shadow: 1px 1px 1px $color-white;
}

form {
  width: $ruler * 20;
  margin: 0 auto;
}

.segment {
  padding: $ruler * 2 0;
  text-align: center;
}

button,
input {
  border: 0;
  outline: 0;
  font-size: $ruler;
  border-radius: $ruler * 20;
  padding: $ruler;
  background-color: $color-bg;
  text-shadow: 1px 1px 0 $color-white;
}

label {
  display: block;
  margin-bottom: $ruler * 1.5;
  width: 100%;
}

input {
  margin-right: $ruler/2;
  box-shadow: inset 2px 2px 5px $color-shadow, inset -5px -5px 10px $color-white;
  width: 100%;
  box-sizing: border-box;
  transition: all 0.2s ease-in-out;
  appearance: none;
  -webkit-appearance: none;

  &:focus {
    box-shadow: inset 1px 1px 2px $color-shadow,
      inset -1px -1px 2px $color-white;
  }
}

button {
  color: #61677c;
  font-weight: bold;
  box-shadow: -5px -5px 20px $color-white, 5px 5px 20px $color-shadow;
  transition: all 0.2s ease-in-out;
  cursor: pointer;
  font-weight: 600;

  &:hover {
    box-shadow: -2px -2px 5px $color-white, 2px 2px 5px $color-shadow;
  }

  &:active {
    box-shadow: inset 1px 1px 2px $color-shadow,
      inset -1px -1px 2px $color-white;
  }

  .icon {
    margin-right: $ruler/2;
  }

  &.unit {
    border-radius: $ruler/2;
    line-height: 0;
    width: $ruler * 3;
    height: $ruler * 3;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    margin: 0 $ruler/2;
    font-size: $ruler * 1.2;

    .icon {
      margin-right: 0;
    }
  }

  &.red {
    display: block;
    width: 100%;
    color: $color-red;
  }
}

.input-group {
  display: flex;
  align-items: center;
  justify-content: flex-start;

  label {
    margin: 0;
    flex: 1;
  }
}
```

## box-shadow实现背景动画 2

box-shadow实现背景动画 。

### 关键点

- 当 box-shadow 的模糊半径和扩张半径都为 0 的时候，我们可以得到一个和元素大小一样的阴影
- box-shadow 是可以设置多层的，也就是多层阴影，而且可以进行过渡变换动画（补间动画）
- background-image: linear-gradient()，也就是渐变背景是不能进行补间动画的

HTML：

```html
<div></div>
```

SCSS：

```scss
@function listShadowOne() {
    $n: 10;
    $m: 5;
    $list: ();
    @for $j from 0 to $m {
        @for $i from 0 to $n {
            $list: $list, $i*10vmin $j*2*10vmin #fff;
        }
    }

    @return $list;
}

@function listShadowThree() {
    $n: 10;
    $m: 5;
    $list: ();
    @for $j from 0 to $m {
        @for $i from 0 to $n {
            $list: $list, $i*10vmin ($j*2-1)*10vmin #fff;
        }
    }

    @return $list;
}

@function listShadowTwo() {
    $n: 10;
    $m: 5;
    $list: ();
    
    @for $j from 0 to $m {
        @for $i from 0 to $n {
            $list: $list, $i*10vmin $j*2*10vmin-10vmin #00f1fc;
        }
    }

    @return $list;
}

@function listShadowFour() {
    $n: 10;
    $m: 5;
    $list: ();
    
    @for $j from 0 to $m {
        @for $i from 0 to $n {
            $list: $list, $i*10vmin ($j*2-1)*10vmin+10vmin #fd0130;
        }
    }

    @return $list;
}


body {
    background: #000;
    overflow: hidden;
}

div {
    position: relative;
    width: 100vmin;
    height: 100vmin;
    margin: 0 auto;
    background: #000;
    animation: scale 5s infinite alternate;
    transform-origin: center center;
}

div::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 5vmin;
    height: 5vmin;
    // background: #fff;
    box-shadow: listShadowOne();
    animation: radiusChange 5s infinite alternate;
}

div::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 5vmin;
    height: 5vmin;
    // background: #fff;
    box-shadow: listShadowThree();
    animation: radiusChangeAfter 5s infinite alternate;
}

@keyframes radiusChange {
    25% {
        box-shadow: listShadowOne();
        border-radius: 50%;
    }
    50% {
        box-shadow: listShadowTwo();
        border-radius: 0%;
    }
    100% {
        box-shadow: listShadowOne();
        border-radius: 50%;
    }
}

@keyframes radiusChangeAfter {
    25% {
        box-shadow: listShadowThree();
        border-radius: 50%;
    }
    50% {
        box-shadow: listShadowFour();
        border-radius: 0%;
    }
    100% {
        box-shadow: listShadowThree();
        border-radius: 50%;
    }
}

@keyframes scale {
    25% {
        transform: scale(2);
    }
    50% {
        transform: scale(2);
    }
}
```

## box-shadow实现背景动画

box-shadow实现背景动画 。

### 关键点

- 当 box-shadow 的模糊半径和扩张半径都为 0 的时候，我们可以得到一个和元素大小一样的阴影
- box-shadow 是可以设置多层的，也就是多层阴影，而且可以进行过渡变换动画（补间动画）
- background-image: linear-gradient()，也就是渐变背景是不能进行补间动画的

HTML：

```html
<div class="shadow"></div>
<div class="gradient"></div>
```

SCSS：

```scss
.shadow {
    position: relative;
    width: 250px;
    height: 250px;
    border: 1px solid #333;
    box-sizing: border-box;
    margin: 50px;
    float: left;
    overflow: hidden;
    
    &::before {
        content: "";
        position: absolute;
        width: 50px;
        height: 50px;
        top: -50px;
        left: -50px;
        box-shadow: 
            50px 50px, 150px 50px, 250px 50px,
            50px 100px, 150px 100px, 250px 100px,
            50px 150px, 150px 150px, 250px 150px,
            50px 200px, 150px 200px, 250px 200px,
            50px 250px, 150px 250px, 250px 250px;
        animation: move 3s infinite linear;
    }
}

@keyframes move {
    25% {
        transform: translate(50px);
        color: coral;
        box-shadow: 
            50px 50px, 150px 50px, 250px 50px,
            50px 100px, 150px 100px, 250px 100px,
            50px 150px, 150px 150px, 250px 150px,
            50px 200px, 150px 200px, 250px 200px,
            50px 250px, 150px 250px, 250px 250px;
    }
    50% {
        transform: translate(0px);
        color: brown;
        border-radius: 0;
        box-shadow: 
            50px 50px, 150px 50px, 250px 50px,
            100px 100px, 200px 100px, 300px 100px,
            50px 150px, 150px 150px, 250px 150px,
            100px 200px, 200px 200px, 300px 200px,
            50px 250px, 150px 250px, 250px 250px;
    }
    75% {
        transform: translate(0px);
        color: teal;
        border-radius: 50%;
        box-shadow: 
            50px 50px, 150px 50px, 250px 50px,
            100px 100px, 200px 100px, 300px 100px,
            50px 150px, 150px 150px, 250px 150px,
            100px 200px, 200px 200px, 300px 200px,
            50px 250px, 150px 250px, 250px 250px;
    }
    100% {
        border-radius: 0%;
        box-shadow: 
            50px 50px, 150px 50px, 250px 50px,
            50px 100px, 150px 100px, 250px 100px,
            50px 150px, 150px 150px, 250px 150px,
            50px 200px, 150px 200px, 250px 200px,
            50px 250px, 150px 250px, 250px 250px;
    }
}

.gradient {
    position: relative;
    width: 250px;
    height: 250px;
    border: 1px solid #333;
    box-sizing: border-box;
    margin: 50px;
    float: left;
    background-image: linear-gradient(90deg, #000 0%, #000 50%, #fff 50%, #fff 100%);
    background-size:  100px 100px;
}
```

## 单标签实现抖音LOGO

单标签实现抖音LOGO。

### 关键点

- 主要借助了两个伪元素实现了整体结构，借助了 drop-shadow 生成一层整体阴影
- drop-shadow 只能是单层阴影，所以另一层阴影需要多尝试
- contrast(150%) brightness(110%) 则可以增强图像的对比度和亮度，更贴近抖音LOGO的效果

HTML：

```html
<div></div>
```

SCSS：

```scss
body {
    background: #000;
    overflow: hidden;
}

div {
    position: relative;
    width: 37px;
    height: 218px;
    margin: 100px auto;
    z-index: 1;
    background: #fff;
    filter:drop-shadow(-10px -10px 0 #24f6f0) contrast(150%) brightness(110%);
    box-shadow: 11.6px 10px 0 0 #fe2d52;
    z-index: 10;
    // transform: skewX(-5deg);
    animation: move 5s infinite ease-in;
    
    &::before {
        content: "";
        position: absolute;
        width: 100px;
        height: 100px;
        border: 37px solid #fff;
        border-top: 37px solid transparent;
        border-radius: 50%;
        top: 123px;
        left: -137px;
        transform: rotate(45deg);
        filter: drop-shadow(16px 0px 0 #fe2d52);
        // mix-blend-mode: overlay;
    }
    
        &::after {
        content: "";
        position: absolute;
        width: 140px;
        height: 140px;
        border: 30px solid #fff;
        border-right: 30px solid transparent;
        border-top: 30px solid transparent;
        border-left: 30px solid transparent;
        top: -100px;
        right: -172px;
        border-radius: 100%;
        transform: rotate(45deg);
        z-index: -10;
        filter:drop-shadow(14px 0 0 #fe2d52);
    }
}

@keyframes move {
    4% {
        transform: skewX(7deg) translate(-30px);
    }
    7% {
        transform: skewX(-6deg) translate(18px);
    }
    9% {
        transform: skewX(5deg) translate(-8px);
    }
    10% {
        transform: skewX(-4deg)translate(6px);
    }
    11% {
        transform: skewX(3deg)translate(-4px);
    }
    12% {
        transform: skewX(-2deg) translate(2px);
    }
    13% {
        transform: skewX(1deg) translate(0px);
        filter:drop-shadow(-10px -10px 0 #24f6f0) contrast(120%) brightness(110%) blur(3px);
    }
    30% {
        filter:drop-shadow(-10px -10px 0 #24f6f0) contrast(150%) brightness(120%) blur(0px);
    }
}
```

## 伪元素 hover 实现纯 CSS 方式控制动画的暂停与播放

伪元素 `:hover` 实现纯 CSS 方式控制动画的暂停与播放。

### 关键点

- 使用 hover 伪类，在鼠标悬停在按钮上面时，控制动画样式的暂停
- 使用了 `~` 选择符对样式进行控制

### 相关文章

[纯 CSS 方式实现 CSS 动画的暂停与播放](https://github.com/chokcoco/iCSS/issues/12)

HTML：

```html
<div class="btn stop">stop</div>
<div class="animation"></div>
```

SCSS：

```scss
.animation {
    width: 100px;
    height: 100px;
    margin: 50px auto;
    background: deeppink;
    animation: move 2s linear infinite alternate;
}

input {
    display: none;
}

@keyframes move {
    0% {
        transform: translate(-100px, 0);
    }
    100% {
        transform: translate(100px, 0);
    }
}

.btn {
    width: 50px;
    margin: 10px auto;
    text-align: center;
    border:1px solid #ddd;
    padding: 10px;
    border-radius: 5px;
    cursor:pointer;
    
    &:hover {
        background: #ddd;
        color: #333;
    }
    
    &:active {
        background: #aaa;
    }
}

.stop:hover ~ .animation {
    animation-play-state: paused;
}
```

## 伪元素 target 实现纯 CSS 方式控制动画的暂停与播放

伪元素 `:target` 实现纯 CSS 方式控制动画的暂停与播放。

### 关键点

- 如何接收点击事件：本例子最重要的核心便是使用 `:target` 伪类接收点击事件
- 如何操作相关DOM：通过兄弟选择符 `~` 控制样式

### 相关文章

[纯CSS的导航栏Tab切换方案](http://www.cnblogs.com/coco1s/p/5955631.html)

HTML：

```html
<div id="stop"></div>
<div id="play"></div>

<div class="box">
    <a class="btn" href="#stop">stop</a>
    <a class="btn" href="#play">play</a>
</div>

<div class="animation"></div>
```

SCSS：

```scss
.animation {
    width: 100px;
    height: 100px;
    margin: 50px auto;
    background: deeppink;
    animation: move 2s linear infinite alternate;
}

input {
    display: none;
}

@keyframes move {
    0% {
        transform: translate(-100px, 0);
    }
    100% {
        transform: translate(100px, 0);
    }
}

.btn {
    display: block;
    width: 50px;
    margin: 10px auto;
    text-align: center;
    border:1px solid #ddd;
    padding: 10px;
    border-radius: 5px;
    cursor:pointer;
    text-decoration: none;
    
    a {
        display: block;
        width: 100%;
        height: 100%;
    }
    
    &:hover {
        background: #ddd;
        color: #333;
    }
    
    &:active {
        background: #aaa;
    }
}

#stop:target ~ .animation {
    animation-play-state: paused;
}

#play:target ~ .animation {
    animation-play-state: running;
}
```

## 伪元素 checked 实现纯 CSS 方式控制动画的暂停与播放

伪元素 `:checked` 实现纯 CSS 方式控制动画的暂停与播放。

### 关键点

- 使用 radio 标签的 `:checked` 伪类，加上 `<label for>` 实现纯 CSS 捕获点击事情
- 使用了 `~` 选择符对样式进行控制

### 相关文章

[纯 CSS 方式实现 CSS 动画的暂停与播放](https://github.com/chokcoco/iCSS/issues/12)

HTML：

```html
<input id="stop" type="radio" name="playAnimation"/>
<input id="play" type="radio" name="playAnimation"/>

<div class="box">
    <label for="stop">
        <div class="btn">stop</div>
    </label>
    <label for="play">
        <div class="btn">play</div>
    </label>
</div>

<div class="animation"></div>
```

SCSS：

```scss
.animation {
    width: 100px;
    height: 100px;
    margin: 50px auto;
    background: deeppink;
    animation: move 2s linear infinite alternate;
}

input {
    display: none;
}

@keyframes move {
    0% {
        transform: translate(-100px, 0);
    }
    100% {
        transform: translate(100px, 0);
    }
}

.btn {
    width: 50px;
    margin: 10px auto;
    text-align: center;
    border:1px solid #ddd;
    padding: 10px;
    border-radius: 5px;
    cursor:pointer;
    
    &:hover {
        background: #ddd;
        color: #333;
    }
    
    &:active {
        background: #aaa;
    }
}

#stop:checked ~ .animation {
    animation-play-state: paused;
}

#play:checked ~ .animation {
    animation-play-state: running;
}
```

## 伪元素实现边界智能判断移动

伪元素实现边界智能判断移动。

### 关键点

- 利用了伪元素生成了 4 个三角形组成了一个正方形，通过 hover 哪个透明的三角形来判断用户的操作方位。

当然，在本题**伪元素**不是必须的，只是简化了标签的使用。

------

HTML：

```html
<div class="box">
    <div class="box__right">Right → Left</div>
    <div class="box__left">Left → Right</div>
    <div class="box__top">Top → Bottom</div>
    <div class="box__bottom">Bottom → Top</div>
    <div class="box__center">Hover from any side</div>
</div>
```

SCSS：

```scss
.box {
    margin: 5em auto;
    position: relative;
    width: 10em;
    height: 10em;
    line-height: 10em;
    overflow: hidden;
}

.box__right,
.box__left,
.box__top,
.box__bottom,
.box__center {
    position: absolute;
    width: inherit;
    height: inherit;
    text-align: center;
    line-height: inherit;
    transition: transform 0.4s ease;
}

.box__right:before,
.box__left:before,
.box__top:before,
.box__bottom:before,
.box__center:before {
    position: absolute;
    content: "";
    width: 70.71%;
    height: 70.71%;
    transform: rotate(45deg);
}

.box__right:hover,
.box__left:hover,
.box__top:hover,
.box__bottom:hover,
.box__center:hover {
    transform: translateX(0);
    z-index: 1;
}

.box__right:hover:before,
.box__left:hover:before,
.box__top:hover:before,
.box__bottom:hover:before,
.box__center:hover:before {
    width: 100%;
    height: 100%;
    transform: none;
}

.box__right {
    background: blue;
    transform: translateX(100%);
}

.box__right:before {
    right: 100%;
    bottom: 0;
    transform-origin: 100% 100%;
}

.box__right:hover ~ .box__center {
    transform: translateX(-100%);
}

.box__left {
    background: green;
    transform: translateX(-100%);
}

.box__left:before {
    left: 100%;
    transform-origin: 0 0;
}

.box__left:hover ~ .box__center {
    transform: translateX(100%);
}

.box__top {
    background: red;
    transform: translateY(-100%);
}

.box__top:before {
    top: 100%;
    right: 0;
    transform-origin: 100% 0;
}

.box__top:hover ~ .box__center {
    transform: translateY(100%);
}

.box__bottom {
    background: yellow;
    transform: translateY(100%);
}

.box__bottom:before {
    bottom: 100%;
    left: 0;
    transform-origin: 0 100%;
}

.box__bottom:hover ~ .box__center {
    transform: translateY(-100%);
}

.box__center {
    background: orange;
    z-index: -1;
}
```

## 使用 checked 伪类实现纯 CSS Tab 切换

使用 `:checked` 来实现 tab 切换功能。

实现 Tab 切换的难点在于如何使用 CSS 接收到用户的点击事情并对相关的节点进行操作。即是：

- 如何接收点击事件
- 如何操作相关DOM

拥有 checked 属性的表单元素， `<input type="radio">` 或者 `<input type="checkbox">` 能够接收到点击事件。

### 关键点

- 使用 radio 标签的 `:checked` 伪类，加上 `<label for>` 实现纯 CSS 捕获点击事情
- 使用了 `~` 选择符对样式进行控制

### 相关文章

[纯CSS的导航栏Tab切换方案](https://www.cnblogs.com/coco1s/p/5955631.html)

HTML：

```html
<div class="container">
    <input class="nav1" id="li1" type="radio" name="nav">
    <input class="nav2" id="li2" type="radio" name="nav">
    <ul class='nav'>
        <li class='active'><label for="li1">列表1</label></li>
        <li><label for="li2">列表2</label></li>
    </ul>
    <div class="content">
        <div class="content1 default">列表1内容:123456</div>
        <div class="content2">列表2内容:abcdefgkijkl</div>
    </div>
</div>
```

SCSS：

```scss
.container{
    position:relative;
    width:400px;
    margin: 50px auto;
}

input{
    display:none;
}

.nav{
    position:relative;
    overflow:hidden;
}

li{
    width:200px;
    float:left;
    text-align:center;
    background:#ddd;
}

li label{
    display:block;
    width:200px;
    line-height:36px;
    font-size:18px;
    cursor:pointer;
}

.content{
    position:relative;
    overflow:hidden;
    width:400px;
    height:100px;
    border:1px solid #999;
    box-sizing:border-box;
    padding:10px;
}

.content1,
.content2{
    display:none;
    width:100%;
    height:100%;
}

.nav1:checked ~ .nav li {
    background:#ddd;
    color:#000;
    
    &:first-child{
        background:#ff7300;
        color:#fff;
    }
}
.nav2:checked ~ .nav li{
    background:#ddd;
    color:#000;
    
    &:last-child{
        background:#ff7300;
        color:#fff;
    }
}

.nav1:checked ~ .content > div{
    display:none;
    
    &:first-child{
    display:block;
    }
}
.nav2:checked ~ .content > div{
    display:none;
    
    &:last-child{
    display:block;
    }
}

.active {
        background:#ff7300;
        color:#fff;
}

.default{
    display:block;
}
```

## 使用 target 伪类实现纯 CSS Tab 切换

使用 `:target` 来实现 tab 切换功能。

实现 Tab 切换的难点在于如何使用 CSS 接收到用户的点击事情并对相关的节点进行操作。即是：

- 如何接收点击事件
- 如何操作相关DOM

### 关键点

- 要使用 `:target` 伪元素，需要 HTML 锚点，以及锚点对应的 HTML 片段
- 核心是使用 `:target` 伪类接收点击事件
- 通过兄弟选择符 `~` 控制样式

### 相关文章

[纯CSS的导航栏Tab切换方案](https://www.cnblogs.com/coco1s/p/5955631.html)

HTML：

```html
<div class="container">
        <div id="content1" class="active">列表1内容:123456</div>
        <div id="content2">列表2内容:abcdefgkijkl</div>
    
        <ul class='nav'>
                <li class="active"><a href="#content1">列表1</a></li>
                <li><a href="#content2">列表2</a></li>
        </ul>
    
        <div class="wrap"></div>
</div>
```

SCSS：

```scss
.container {
    position: relative;
    width: 400px;
    margin: 50px auto;
}

.nav {
    position: relative;
    overflow: hidden;
}

li {
    width: 200px;
    float: left;
    text-align: center;
    background: #ddd;
}

li a {
    display: block;
    width: 200px;
    line-height: 36px;
    font-size: 18px;
    cursor: pointer;
    text-decoration: none;
    color: #000;
}

#content1,
#content2 {
    position: absolute;
    overflow: hidden;
    top: 36px;
    width: 400px;
    height: 100px;
    border: 1px solid #999;
    box-sizing: border-box;
    padding: 10px;
}

#content1,
#content2 {
    display: none;
    width: 100%;
    background: #fff;
}

#content1:target,
#content2:target {
    display: block;
}

#content1.active {
    display: block;
}

.active ~ .nav li {
    &:first-child {
        background: #ff7300;
        color: #fff;
    }
}

#content1:target ~ .nav li {
    background: #ddd;
    color: #000;

    // 改变li元素的背景色和字体颜色
    &:first-child {
        background: #ff7300;
        color: #fff;
    }
}

#content2:target ~ .nav li {
    background: #ddd;
    color: #000;

    // 改变li元素的背景色和字体颜色
    &:last-child {
        background: #ff7300;
        color: #fff;
    }
}

.wrap {
    position: absolute;
    overflow: hidden;
    top: 36px;
    width: 400px;
    height: 100px;
    border: 1px solid #999;
    box-sizing: border-box;
}
```

## focus-within switch tab

使用 `:focus-within` 来实现 tab 切换功能。

`:focus-within` 它表示一个元素获得焦点，或，该元素的后代元素获得焦点。划重点，它或它的后代获得焦点。

这也就意味着，它或它的后代获得焦点，都可以触发 :focus-within。

### 关键点

- 这个属性有点类似 Javascript 的事件冒泡，从可获焦元素开始一直冒泡到根元素 html，都可以接收触发 :focus-within 事件
- 本例子的思路就是通过获焦态来控制其他选择器，以及最重要的是利用了父级的 :not(:focus-within) 来设置默认样式

### 相关文章

[神奇的选择器 :focus-within](https://github.com/chokcoco/iCSS/issues/36)

HTML：

```html
<div class="container">
    <div class="nav-box">
        <button class="nav-A">Tab-A</button>
        <button class="nav-B">Tab-B</button>
        <div class="content-box">
            <div class="content-A">
                content-A
            </div>
            <div class="content-B">
                content-B
            </div>
        </div>
    </div>
</div>
```

SCSS：

```scss
.container {
    width: 300px;
    margin: 50px auto;
    padding: 10px;
    boder: 1px solid #ddd;
}

.nav-box {
    font-size: 0;
}

button {
    width: 150px; 
    height: 64px;
    box-sizing: border-box;
    outline: none;
    background: #fff;
    border: 1px solid #ddd;
    font-size: 18px;
    cursor: pointer;
}

button:focus-within {
    color: #fff;
    background: #ffcc00;
}

.content-box {
    font-size: 24px;
    border: 1px solid #ddd;
    height: 100px;
    div {
        display: none;
    }
}

.nav-box:not(:focus-within) {
    .nav-A {
        color: #fff;
        background: #ffcc00;
    }
    
    .content-A {
        display: block;
    }
}

.nav-A:focus-within ~ .content-box .content-A {
    display: block;
}

.nav-B:focus-within ~ .content-box .content-B {
    display: block;
}
```

## 伪元素实现打点 loading 效果

伪元素实现打点 loading 效果。

### 关键点

- 非常有意思，借助动画操控伪元素的 content

一看就懂：

HTML：

```html
<p>加载中</p>
```

SCSS：

```scss
p {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);  
    font-size: 6vw;
    line-height: 8vw;
}

p::after {
    content: "";
    position: absolute;
    top: 0%;
    bottom: 0;
    animation: dot 3s infinite steps(3, start);
    line-height: 9vw;
}

@keyframes dot {
    33.33% {
        content: ".";
    }
    66.67% {
        content: "..";
    }
    100% {
        content: "...";
    }
}
```

## 使用:not()伪类实现弹窗背景元素模糊

使用:not()伪类实现弹窗背景元素模糊。

### 用法

CSS 否定伪类，:not(X)，是以一个简单的以选择器X为参数的功能性标记函数。它匹配不符合参数选择器X描述的元素。

### not 伪类关键点

- 可以利用这个伪类写一个完全没有用处的选择器。例如， :not(*) 匹配任何非元素的元素，因此这个规则将永远不会被应用。
- 可以利用这个伪类提高规则的优先级。例如， #foo:not(#bar) 和 #foo 会匹配相同的元素。 但是前者的优先级更高。
- :not(foo) 将匹配任何非foo元素，包括html和body。
- 这个选择器只会应用在一个元素上，你无法用它排除所有父元素。比如， body :not(table) a 将依旧会应用在table内部的`<a>` 上, 因为 `<tr>`将会被 :not()这部分选择器匹配。

------

HTML：

```html
<div class="container s-blur">
    <div class="g-header">Header</div>
    <div class="g-content">
        <p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p>
        <p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p>
        <p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p>
        <p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p>
        <p>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</p>
    </div>
    <div class="g-footer">Footer</div>
    <div class="g-wrap">
        利用:not()伪类使除了弹窗之外的所有元素都进行模糊
    </div>
</div>
```

SCSS：

```scss
.s-blur > :not(.g-wrap){
    filter: blur(2px);
    
    &::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,.3);
        filter: blur(2px);
        z-index: 2;
    }
}

.g-wrap {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50vw;
    height: 50vh;
    background: #000;
    color: #fff;
    text-align: center;
    line-height: 50vh;
    font-size: 30px;
}

.g-container {
    position: relative;
}

.g-header,
.g-content,
.g-footer{
    padding: 20px;
    text-align: center;
    font-size: 20px;
    line-height: 40px;
    box-sizing: border-box;
    color: #fff;
    overflow: hidden;
}

.g-header,
.g-footer{
    height: 20vh;
    background: brown;
}

.g-content {
    height: 60vh;
    background: #77ccdd;
}
```

## 小球穿梭放大loading动画

小球穿梭放大loading动画。

### 关键点

主要使用了 blur、contrast 两个滤镜，它们的作用分别是：

- filter: blur()： 给图像设置高斯模糊效果。
- filter: contrast()： 调整图像的对比度。

但是，当他们“合体”的时候，产生了奇妙的融合现象，通过对比度滤镜把高斯模糊的模糊边缘给干掉，利用高斯模糊实现融合效果。

------

HTML：

```HTML
<div class="g-container">
    <div class="g-first"></div>
    <div class="g-ball"></div>
    <div class="g-ball"></div>
    <div class="g-ball"></div>
    <div class="g-ball"></div>
    <div class="g-ball"></div>
    <div class="g-ball"></div>
    <div class="g-ball"></div>
</div>
```

SCSS：

```scss
$count: 7;

body,
html {
    width: 100%;
    height: 100%;
    display: flex;
    filter: blur(4px) contrast(8);
    background: #000;
    display: flex;
}

.g-container {
    margin: auto;
    position: relative;
    width: 10vmin;
    height: 10vmin;
}

.g-ball,
.g-first{
    position: absolute;
    top:0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #fff;
    border-radius: 50%;
    transform: translate(-700%, 0);
    opacity: 0;
    // animation: move 3s infinite linear;
}

@for $i from 0 through $count { 
    .g-ball:nth-child(#{$i}) {
        animation: move 3.5s infinite #{$i * 0.2 + 0.1}s linear;
    }
}

.g-first {
    animation: scaleMove 3.5s infinite linear;
}

@keyframes move {
    25% {
        opacity: 1;
        transform: translate(-1vw, 0);
    }
    50% {
        opacity: 1;
        transform: translate(1vw, 0);
    }
    75%,
    100% {
        opacity: 0;
        transform: translate(700%, 0);
    }
}


@keyframes scaleMove {
    25% {
        opacity: 1;
        transform: translate(-1vw, 0);
    }
    35% {
        opacity: 1;
        transform: scale(1);
    }
    70% {
        opacity: 1;
        transform: translate(1vw, 0) scale(2);
    }
    90%,
    100% {
        opacity: 0;
        transform: translate(1vw, 0) scale(1);
    }
}
```

## 小球穿梭效果

小球穿梭效果。

### 关键点

主要使用了 blur、contrast 两个滤镜，它们的作用分别是：

- filter: blur()： 给图像设置高斯模糊效果。
- filter: contrast()： 调整图像的对比度。

但是，当他们“合体”的时候，产生了奇妙的融合现象，通过对比度滤镜把高斯模糊的模糊边缘给干掉，利用高斯模糊实现融合效果。

------

HTML：

```HTML
<div class="ball"></div>

<div class="g-wall"></div>
<div class="g-wall"></div>
<div class="g-wall"></div>
<div class="g-wall"></div>
```

SCSS：

```scss
body {
    background: #000;
    filter: blur(5px) contrast(10);
    overflow: hidden;
}

.ball {
    position: absolute;
    left: 0; 
    top: 40vh;
    height: 20vh;
    width: 20vh;
    border-radius: 50%;
    background: #fff;
    animation: move 10s infinite;
    
}

.g-wall {
    position: absolute;
    left: 20%; 
    top: 30vh;
    height: 40vh;
    width: 15vh;
    border-radius: 50%;
    background: rgba(0, 0, 0, .5);
}

.g-wall:nth-child(2) {
    left: 40%; 
    border-radius: 50%;
}

.g-wall:nth-child(3) {
    left: 60%; 
    border-radius: 50%;
}

.g-wall:nth-child(4) {
    left: 80%; 
    border-radius: 50%;
}

@keyframes move {
    
    20% {
        transform: translate(20vw, 0);
        background: #ddd;
    }
    
    100% {
        transform: translate(100vw, 0);
        background: #ddd;
    }
}
```

## 使用 filter:blur | filter:constrast 生成特殊融合效果

使用 filter:blur | filter:constrast 生成特殊融合效果。

### 关键点

本例子中两个单独的滤镜拿出来，它们的作用分别是：

- filter: blur()： 给图像设置高斯模糊效果。
- filter: contrast()： 调整图像的对比度。

但是，当他们“合体”的时候，产生了奇妙的融合现象，通过对比度滤镜把高斯模糊的模糊边缘给干掉，利用高斯模糊实现融合效果。

------

HTML：

```pug
// pug 模版
.container
    .bg
    - for(var i=0; i<1; i++)
        .box
```

SCSS：

```scss
.container {
    position: absolute;
    width: 300px;
    height: 300px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #fff;
    border-radius: 50%;
    filter: contrast(20);
}

.bg {
    position: absolute;
    width: 200px;
    height: 200px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background-color: #000;
    filter: contrast(20) blur(6px);
    
}

.box {
    position: absolute;
    top: 50%;
    left: 80px;
    transform: translate(-50%, -50%) rotate(0);
    background-color: blue;
    border-radius: 50%;
    width: 100px;
    height: 100px;
    filter: unset;
    filter: contrast(20) blur(6px);
    animation: turn 5s linear infinite;
    transform-origin: -100% center;
}

@keyframes turn {
    100% {
        transform: translate(-50%, -50%) rotate(360deg);
    }
}
```

## 使用 filter:blur | filter:constrast 生成火焰效果2

使用 filter:blur | filter:constrast 生成火焰效果。

### 关键点

本 Demo 详细信息可阅读：

[CSS 火焰？不在话下](https://github.com/chokcoco/iCSS/issues/62)

------

HTML：

```pug
// pug 模版
div.g-candle
    div.g-body
    div.g-fire-box
        div.g-fire
            -for(var i=0; i<200; i++)
                div.g-ball   
```

SCSS：

```scss
$count: 200;

html, body{
    height: 100%;
    background: #000;
    overflow: hidden;
    // filter: blur(1px) contrast(5);
}

.g-candle {
    position: aboslute;
    width: 400px;
    margin: 0 auto;
    height: 400px;
}

.g-body {
    position: relative;
    width: 100px;
    height: 300px;
    margin: 280px auto;
    // border: 1px solid #fff;
    background: linear-gradient(230deg, #ca9800, #573903, black 70%);
    z-index: 1;
    
    &::before {
        position: absolute;
        content: "";
        width: 100px;
        height: 40px;
        border-radius: 50%;
        // border: 1px solid #fff;
        box-sizing: border-box;
        top: -20px;
        background: radial-gradient(#a46800, #5c3104 45%, #905602 100%);
    }
    
    &::after {
        position: absolute;
        content: "";
        width: 4px;
        height: 48px;
        background: #fff;
        left: 50%;
        top: -22px;
        transform: translate(-50%, -50%);
        border-radius: 50% 50% 0 0;
        background: linear-gradient(180deg, rgba(0, 0, 0, .3) 0%, rgba(0, 0, 0, .8) 60%, #fff);
        opacity: .7;
        filter: blur(1px);
    }
}

.g-fire-box {
    position: absolute;
    top: 97px;
    left: 50%;
    width: 80px;
    height: 200px;
    transform: translate(-50%, -50%);
    filter: blur(2px) contrast(20);
}

.g-fire {
    position: absolute;
    top: 30px;
    left: 50%;
    border-radius: 45%;
    box-sizing: border-box;
    border: 120px solid #000;
    border-bottom: 120px solid transparent;
    transform: translate(-50%, 0) scaleX(.45);
    background-color: #761b00;
    // filter: blur(20px) contrast(30);

}

.g-ball {
    position: absolute;
    top: 60px;
    transform: translate(0, 0);
    background: #fa8763;
    border-radius: 50%;
    z-index: -1;
    mix-blend-mode: screen;
}

@for $i from 0 to $count {
    .g-ball:nth-child(#{$i}) {
        $width: #{random(50)}px;
        
        width: $width;
        height: $width;
        left: calc(#{(random(70))}px - 55px);
    }
    
    .g-ball:nth-child(#{$i}) {
        animation: movetop 1s linear -#{random(3000)/1000}s infinite;
    }
}

@keyframes movetop {
    0% {
        transform: translate(0, 0);
    }
    20% {
        transform: translate(0, 0);
    }
    87.7% {
        transform: translate(0, -170px);
        opacity: 0;
    }
    100% {
        transform: translate(0, -170px);
        opacity: 0;
    }
}
```

## 使用 filter:blur | filter:constrast 生成火焰效果

使用 filter:blur | filter:constrast 生成火焰效果。

### 关键点

本例子中两个单独的滤镜拿出来，它们的作用分别是：

- filter: blur()： 给图像设置高斯模糊效果。
- filter: contrast()： 调整图像的对比度。

但是，当他们“合体”的时候，产生了奇妙的融合现象，通过对比度滤镜把高斯模糊的模糊边缘给干掉，利用高斯模糊实现融合效果。

------

先来看看火焰的核心代码：

```css
.fire {
    width: 0;
    height: 0;
    border-radius: 45%;
    box-sizing: border-box;
    border: 100px solid #000;
    border-bottom: 100pxsolid transparent;
    background-color: #b5932f;
    transform: scaleX(.4);
    filter: blur(20px) contrast(30);
}
```

分解一下过程：

![img](https://user-images.githubusercontent.com/8554143/30368522-f746afba-98a3-11e7-93b8-92e2e2c1c622.png)

接下来，我们只需要在火焰 .fire 这个 div 内部，用大量的黑色圆形，由下至上，无规律穿过火焰即可。由于滤镜的融合效果，火焰效果随之产生。

这里为了方便理解，我把背景色切换成白色，火焰动画原理一看即懂：

![img](https://user-images.githubusercontent.com/8554143/30369622-bc2b3e6a-98a7-11e7-9422-170d6151c46c.gif)

------

HTML：

```pug
// pug 模版
.g-container
    .g-fire
        - for (var j = 1; j <=40; j++)
            .g-dot
```

SCSS：

```scss
$douCount: 40;
$animationTime: 2;
$delayTime: 3;

@function randomNum($max, $min: 0) {
    @return ($min + random($max));
}

body {
    background: #000;
    overflow: hidden;
}

:root {
    --fireWidth: 115px;
    --fireHeight: 200px;
    --dotSize: 24px;
    --fireColor: #b5932f;
    // --fireColor: #008eff;
    // --fireColor: #ff9900;
    
}

.g-container {
    position: relative;
    width: 384px;
    height: 300px;
    margin: 0 auto;
    background-color: #000;
}

.g-fire {
    position: absolute;
    width: 0;
    height: 0;
    bottom: 100px;
    left: 50%;
    border-radius: 45%;
    box-sizing: border-box;
    border: 200px solid #000;
    border-bottom: 200px solid transparent;
    transform: translate(-50%, 0) scaleX(.4);
    background-color: var(--fireColor);
    filter: blur(20px) contrast(30);
}

.g-dot {
    position: absolute;
    bottom: -210px;
    left: 0;
    width: var(--dotSize);
    height: var(--dotSize);
    background: #000;
    border-radius: 50%;
}

@for $i from 1 to $douCount + 1 {
    .g-dot:nth-child(#{$i}) {
        bottom: -#{randomNum(120, 240)}px;
        left: #{randomNum(300, -160)}px;
        animation: move #{randomNum($animationTime * 13, 7) / 10}s infinite #{randomNum($delayTime * 20) / 10}s linear;
    }
}

@keyframes move {
    100% {
        transform: translate3d(0, -350px, 0);
    }
}
```

## 单标签纯CSS实现幽灵动画

单标签纯CSS实现幽灵动画。

### 关键点

- filter: blur() | filter: contrast() 的配合使用
- 单标签的限制，所以多重渐变也发挥了很重要的作用

HTML：

```HTML
<div></div>
```

SCSS：

```scss
html,
body {
    width: 100%;
    height: 100%;
    display: flex;
    background: #000;
    filter: blur(3px) contrast(10);
}

div {
    position: relative;
    width: 80px;
    height: 120px;
    background: 
        radial-gradient(circle at 60px 40px, #000, #000 7px, transparent 7px),
        radial-gradient(circle at 40px 40px, #000, #000 7px, transparent 7px),
        radial-gradient(circle at 50px 50px, #fff, #fff);
    background-size: 100% 100%; 
    background-repeat: no-repeat;
    margin: auto;
    border-radius: 40px 40px 60px 20px;
    transform: skewX(-10deg);
    animation: moveMain 2s infinite ease-out;
}

div::before,
div::after {
    content: "";
    position: absolute;
    background: #fff;
    border-radius: 50%;
}

div::before {
    width: 20px;
    height: 20px;
    top: 50px;
    left: -10px;
    box-shadow: 0 0 0 1px #fff;
    animation: move 2s infinite ease-in;
}

div::after {
    width: 30px;
    height: 25px;
    top: 95px;
    left: -10px;
    box-shadow: 0 0 0 1px #fff;
    animation: move2 2s infinite ease-in;
}

@keyframes move {
    80%,
    100% {
        box-shadow: -60px 0 0 .5px rgba(255, 255, 255, .5);
    }
}

@keyframes move2 {
    80%,
    100% {
        box-shadow: -100px 0 0 .5px rgba(255, 255, 255, .2);
    }
}

@keyframes moveMain {
    42% {
        transform: skewX(-10deg) translate(40px, 0);
    }
}
```

## 使用 hue-rotate 实现渐变背景动画

使用 hue-rotate 实现渐变背景动画。

这种方法应该是实现渐变背景动画的比较好的方法。

HTML：

```HTML
<div></div>
```

SCSS：

```scss
div {
    width: 300px;
    height: 180px;
    margin: auto;
    background: linear-gradient(45deg, #ffc107, deeppink, #9c27b0);
    animation: hueRotate 10s infinite alternate;
}

@keyframes hueRotate {
    100% {
        filter: hue-rotate(360deg);
    }
}
```

## 滤镜及混合模式混搭特效

使用滤镜及混合模式混搭特效。

本例子中用到了：

- filter: contrast()
- filter: brightness()
- filter: blur()
- background-blend-mode: multiply
- mix-blend-mode: saturation

------

HTML：

```html
<div class="halftone">
    <img src="https://avatars3.githubusercontent.com/u/8554143?s=460&v=4">
</div>
```

SCSS：

```scss
.halftone {
  position: absolute;
  width: 20vw;
  height: 20vw;
  background: white;
  top: 50%;
  left: 50%;
  filter: contrast(100000%);
  transform: translate(-50%, -50%);
  overflow: hidden; // 电脑性能好的，关掉这个属性
}

.halftone > img {
  width: 100%;
  height: 100%;
  filter: brightness(0.5) blur(4px);
  animation: 3s animation-filter infinite alternate;
}

.halftone::after {
  content: "";
  position: absolute;
  top: -100%;
  left: -100%;
  right: -100%;
  bottom: -100%;
  background-blend-mode: multiply;
  background: radial-gradient(8px 8px, cyan, white),
        radial-gradient(8px 8px, magenta, white),
        radial-gradient(8px 8px, yellow, white);
  background-size: 8px 8px;
  background-position: 0 -3px, -2px 0, 2px 0;
  mix-blend-mode: saturation;
  pointer-events: none;
  transform: rotate(11.25deg);
  transition: 1s ease-in-out transform;
  z-index: 1;
  animation: 3s animation-overlay infinite alternate;
}

@keyframes animation-overlay {
  0% {
    transform: rotate(450deg) scale(15);
  }

  100% {
    transform: rotate(-90deg);
  }
}

@keyframes animation-filter {
  0% {
    filter: brightness(0.5) blur(40px);
  }

  100% {
    filter: brightness(0.5) blur(4px);
  }
}
```

## 单标签实现滴水效果

单标签实现滴水效果。

### 关键点

主要使用了 blur、contrast 两个滤镜，它们的作用分别是：

- filter: blur()： 给图像设置高斯模糊效果。
- filter: contrast()： 调整图像的对比度。

但是，当他们“合体”的时候，产生了奇妙的融合现象，通过对比度滤镜把高斯模糊的模糊边缘给干掉，利用高斯模糊实现融合效果。

------

HTML：

```HTML
<div>MAGICCSS</div>
```

SCSS：

```scss
div {
    position: relative;
    width: 640px;
    height: 106px;
    color: #fff;
    font-size: 124px;
    text-align: center;
    margin: 100px auto;
    border-bottom: 10px solid #fff;
    transform: skewY(5deg);
    
    &::before,
    &::after {
        position: absolute;
        content: "";
        bottom : -20px;
        left: 0;
        width: 10px;
        height: 20px;
        border-radius: 50%;
        background: #fff;
        transform: translate(0, 0);
        animation: move 7.5s ease-in-out infinite;
    }
    
    &::after {
        animation: move 7.5s ease-in-out 1s infinite;
    }
}

@keyframes move {
    80% {        
        bottom : -30px;
        transform: translate(623px, 0);
    } 93% {
        transform: translate(623px, 3px);
        opacity: 1;
    }100% {
        transform: translate(623px, 150px);
        opacity: 0;
    }
}
```

## 利用 filter:blur 增强文字的 3D 效果

利用 filter:blur 增强文字的 3D 效果

### 关键点

1. 第一个字符和最后一个字符在旋转的最左效果和最右效果下分别会离我们最近和最远，它们的效果其实应该是一致的，所以第一个字符和最后一个字符应该统一处理，依次类推，第二个字符和倒数第二字符统一处理，这里可以借助 SASS 利用 `:nth-child` 和 `:nth-last-child` 高效编写 CSS 代码
2. 每次有一半是清晰的，一半的是模糊的，需要区分对待，利用 `animation-delay` 让一半的动画延迟一半进行
3. 可以再配合 `text-shadow` 让文字更立体点

HTML：

```
<p>
    <span>C</span>
    <span>S</span>
    <span>S</span>
    <span>3</span>
    <span>D</span>
    <span>E</span>
    <span>F</span>
    <span>F</span>
    <span>E</span>
    <span>C</span>
    <span>T</span>
</p>
```

SCSS：

```scss
@import url('https://fonts.googleapis.com/css2?family=Lobster&display=swap');

$count: 12;

body, html {
    width: 100%;
    height: 100%;
    display: flex;
    font-family: 'Lobster', cursive;
    perspective: 160vmin;
    overflow: hidden;
}

p {
    margin: auto;
    font-size: 24vmin;
    white-space: nowrap;
    transform-style: preserve-3d;
    animation: rotate 10s infinite ease-in-out;
    
    span {
        text-shadow: 
            1px 1px 0 rgba(0, 0, 0, .9),
            2px 2px 0 rgba(0, 0, 0, .7),
            3px 3px 0 rgba(0, 0, 0, .5),
            4px 4px 0 rgba(0, 0, 0, .3),
            5px 5px 0 rgba(0, 0, 0, .1);
        
        &:nth-child(-n+5) { 
            animation-delay: -5s; 
        }
    }
}

@for $i from 1 to 7 {
    span:nth-child(#{$i}), 
    span:nth-last-child(#{$i}) {
        animation: filterBlur-#{$i} 10s infinite ease-in-out;
    }
    @keyframes filterBlur-#{$i} {
        0% {
            filter: blur(0px) contrast(5);
        }
        50% {
            filter: blur(#{7 - $i}px) contrast(1);
        }
        100% {
            filter: blur(0px) contrast(5);
        }
    }
}
@keyframes rotate {
    0% {
        transform: rotateY(-45deg);
    }
    50% {
        transform: rotateY(45deg);
    }
    100% {
        transform: rotateY(-45deg);
    }
}
```

## 活用 border-radius, 实现充电动画

活用 border-radius, 实现充电动画

关于本效果的详细信息，可以看看这篇文章：

[巧用 CSS 实现酷炫的充电动画](https://github.com/chokcoco/iCSS/issues/75)

HTML：

```html
<div class="container">
    <div class="header"></div>
    <div class="battery">
    </div>
    <div class="battery-copy">
        <div class="g-wave"></div>
        <div class="g-wave"></div>
        <div class="g-wave"></div>
    </div>
</div>
```

SCSS：

```scss
.container {
    position: relative;
    width: 140px;
    margin: auto;
}

.header {
    position: absolute;
    width: 26px;
    height: 10px;
    left: 50%;
    top: 0;
    transform: translate(-50%, -10px);
    border-radius: 5px 5px 0 0;
    background: rgba(255, 255, 255, .88);
}

.battery-copy {
    position: absolute;
    top: 0;
    left: 0;
    height: 220px;
    width: 140px;
    border-radius: 15px 15px 5px 5px;
    overflow: hidden;
}

.battery {
    position: relative;
    height: 220px;
    box-sizing: border-box;
    border-radius: 15px 15px 5px 5px;
    box-shadow: 0 0 5px 2px rgba(255, 255, 255, 0.22);
    background: #fff;
    z-index: 1;
    
    &::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        top: 80%;
        background: linear-gradient(to bottom, #7abcff 0%, #00BCD4 44%, #2196F3 100%);
        border-radius: 0px 0px 5px 5px;
        box-shadow: 0 14px 28px rgba(33, 150, 243, 0), 0 10px 10px rgba(9, 188, 215, 0.08);
        animation: charging 10s linear infinite;
        filter: hue-rotate(90deg);
    }
}

.g-wave {
    position: absolute;
    width: 300px;
    height: 300px;
    background: rgba(255, 255, 255, .8);
    border-radius: 45% 47% 44% 42%;
    bottom: 25px;
    left: 50%;
    transform: translate(-50%, 0);
    z-index: 1;
    animation: move 10s linear infinite;
}

.g-wave:nth-child(2) {
    border-radius: 38% 46% 43% 47%;
    transform: translate(-50%, 0) rotate(-135deg);
}

.g-wave:nth-child(3) {
    border-radius: 42% 46% 37% 40%;
    transform: translate(-50%, 0) rotate(135deg);
}

@keyframes charging {
    50% {
        box-shadow: 0 14px 28px rgba(0, 150, 136, 0.83), 0px 4px 10px rgba(9, 188, 215, 0.4);
    }
    
    95% {
        top: 5%;
        filter: hue-rotate(0deg);
        border-radius: 0 0 5px 5px;
        box-shadow: 0 14px 28px rgba(4, 188, 213, .2), 0 10px 10px rgba(9, 188, 215, 0.08);
    }
    100% {
        top: 0%;
        filter: hue-rotate(0deg);
        border-radius: 15px 15px 5px 5px;
        box-shadow: 0 14px 28px rgba(4, 188, 213, 0), 0 10px 10px rgba(9, 188, 215, 0.4);
    }
}

@keyframes move {
    100% {
        transform: translate(-50%, -160px) rotate(720deg);
    }
}
```

## 活用 border-radius, 单标签线条动画

活用 border-radius, 单标签线条动画。

### 关键点

这个效果，其实更多的还是因为 filter 的 blur 和 contrast 滤镜。

然后通过旋转 `border-radius` 四个角值不同的 div 得到。

------

HTML：

```html
<div></div>
```

SCSS：

```scss
html,
body{
    width: 100%;
    height: 100%;
    overflow: hidden;
}
body {
    background: #000;
    filter: blur(5px) contrast(20);
    
    &::before {
        position: absolute;
        content: "";
        background: #000;
        top: 0;
        left: 0;
        right: 0;
        height: 20vh;
        z-index: 10;
    }
}

div {
    position: relative;
    width: 30vmin;
    height: 30vmin;
    margin: 30vh auto;
    // border: 1vmin solid #fff; 
    border-radius: 46% 42% 47% 44%;
    background: linear-gradient(#fff, #9c27b0);
    transform: scale(15) translate(0, -13vh) rotate(0deg);
    animation: rotate 10s infinite linear alternate;

    &::before {
        content: "";
        position: absolute;
        width: 99%;
        height: 99%;
        background: #000;
        border-radius: 46% 42% 47% 44%;
        transform: translate(-50%, -50%);
        left: 50%;
        top: 50%;
    }
}

@keyframes rotate {
    100% {
        transform: scale(10) translate(0, -15vh) rotate(360deg);
    }
}

@keyframes move {
    50% {
        left: 50%;
        right: 49.95%;
    }
    100% {
        left: 90%;
        right: 9.7%;
    }
}
```

## 使用 border-radius 的变化模拟绳子下坠

使用 border-radius 的变化模拟绳子下坠。

### 关键点

很有意思的一个小动画，精髓在于使用 border-radius 的变化模拟绳子下坠的感觉。

------

HTML：

```html
<div class="g-container">
    <div class="g-line"></div>
    <div class="g-ground"></div>
    <div class="g-man">
        <div class="g-hand"></div>
    </div>
</div>
```

SCSS：

```scss
.g-container {
    position: relative;
    width: 400px;
    height: 100vh;
    margin: auto;
    // display: flex;
}

.g-line {
    position: absolute;
    left: 200px;
    width: 100px;
    height: 100px;
    border-radius: 0 0 0 120px;
    border: 1px solid #000;
    border-top: none;
    // border-bottom: none;
    border-right: none;
    transform-origin: 0 0;
    animation: lineMove 6s ease-in-out infinite;
    transform: rotate(-90deg);
    // transform: rotate(15deg);
    // height: 290px;
    // width: 50px;
    // border-radius: 0 0 0 90%;
}

.g-man {
    position: absolute;
    top: 240px;
    left: 170px;
    width: 1px;
    height: 40px;
    background: #000;

    opacity: 0;
    animation: manShow 6s infinite ease-in-out;
    
    &:before {
        position: absolute;
        content: "";
        top: -100%;
        left: -12px;
        width: 25px;
        height: 40px;
        border-radius: 100%;
        border: 1px solid #333;
        animation: headrotate 6s infinite ease-in-out;
    }
    
    &::after {
        content: "";
        position: absolute;
        left: 50%;
        top: 110%;
        transform: translate(-50%, 0) rotate(45deg);
        transform-origin: center center;
        width: 30px;
        height: 30px;
        border: 1px solid #333;
        border-right: none;
        border-bottom: none;
        animation: footerShrink 6s infinite ease-in-out;
    }
}

.g-hand {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-20%, 0);
    width: 50px;
    height: 1px;
    background: #000;
    animation: manhandmove 6s infinite ease-in-out;
}

.g-ground {
    position: absolute;
    width: 120px;
    height: 1px;
    margin-top: 300px;
    margin-left: 100px;
    // background: #000;
    animation: groundShow 6s infinite;
}

@keyframes lineMove {
    15% {
        width: 80px;
        height: 270px;
    }
    27% {
        border-radius: 0 0 0 90%;
    }
    35% {
        width: 0px;
        height: 290px;
        border-radius: 0 0 0 90%;
        transform: rotate(20deg);
    }
    45% {
        width: 0px;
        height: 300px;
        border-radius: 0 0 0 0px;
        transform: rotate(-8deg);
    }
    53% {
        width: 0px;
        height: 300px;
        border-radius: 0 0 0 0px;
        transform: rotate(3deg);
    }
    60% {
        width: 0px;
        height: 300px;
        border-radius: 0 0 0 0px;
        transform: rotate(0deg);
    }
    85% {
        width: 0px;
        height: 25px;
        border-radius: 0 0 0 0px;
        transform: rotate(0deg);
    }
    100% {
        width: 0px;
        height: 0px;
        border-radius: 0 0 0 0px;
        transform: rotate(0deg);
    }
        
} 

@keyframes groundShow {
    29% {
        background: opacity;
    }
    30% {
        background: #000;
    }
    31.9% {
        backgroun: #000;
    }
    32% {
        background: opacity;
    }
    33.9% {
        background: opacity;
    }
    34% {
        background: #000;
    }
    60% {
        background: #000;
    }
    61% {
        background: opacity;
    }
}

@keyframes manShow {
    30% {
        top: 240px;
        opacity: 1;
    }
    60% {
        top: 240px;
    }
    85% {
        top: 0;
        opacity: 1;
    }
    100% {
        top: -10px;
        opacity: 0;
    }
}

@keyframes manhandmove{
    55% {
        transform: translate(-20%, 0) rotate(0deg);
    }
    60% {
        transform: translate(-24%, 0) rotate(-30deg);
    }
    100% {
        ransform: translate(-24%, 0) rotate(-30deg);
    }
}

@keyframes headrotate {
    55% {
        transform: rotate(0);
    }
    60% {
        transform: rotate(-25deg);
    }
    100% {
        transform: rotate(-20deg);
    }
}
```

## 巧用 overflow 及实现边框线条动画

巧用 overflow 及实现边框线条动画。

借助 overflow 是实现 CSS 效果非常常见的手段。

HTML：

```html
<div>Hover Me</div>
```

SCSS：

```scss
div {
    position: relative;
    margin: auto;
    width: 200px;
    height: 100px;
    line-height: 100px;
    text-align: center;
    overflow: hidden;
    
    &::after {
        content: "Hover Me";
        position: absolute;
        top: 4px;
        bottom: 4px;
        right: 4px;
        left: 4px;
        line-height: 92px;
        font-size: 24px;
        background: #fff;
        border: 2px solid yellowgreen;
        cursor: pointer;
        color: yellowgreen;
    }
    
    &::before {
        content: "";
        position: absolute;
        top: 0px;
        bottom: 0px;
        right: -20px;
        left: 0px;
        background: #fff;
        transform: rotateZ(-90deg) translate(-100%, -100%);
        transform-origin: top left;
        transition: transform .3s;
        transition-timing-function: linear;
    }
    
    &:hover::before {
        transform: rotateZ(0deg) translate(0%, -0%);
    }
}
```

## border-color 变换实现文字输入效果

border-color 变换实现文字输入效果。

### 关键点

- 利用 border-right 实现光标闪烁

------

HTML：

```html
<h1>Pure CSS Typing animation.</h1>
```

SCSS：

```scss
body {
    background: black;
    color: #fff;
}

h1 {
    font: bold 200% Consolas, Monaco, monospace;
    border-right: 0.1em solid;
    width: 16.5em;
    width: 26ch;
    margin: 2em 1em;
    white-space: nowrap;
    overflow: hidden;
    animation: typing 3s steps(26, end),
        cursor-blink 0.3s step-end infinite alternate;
}

@keyframes typing {
    from {
        width: 0;
    }
}

@keyframes cursor-blink {
    50% {
        border-color: transparent;
    }
}
```

## 活用 border-radius, 实现波浪百分比图

活用 border-radius, 实现波浪百分比图。

### 关键点

- 利用 border-radius 生成椭圆
- 并不是利用旋转的椭圆本身生成波浪效果，而是利用它去切割背景，产生波浪的效果。

详见：[纯 CSS 实现波浪效果！](https://www.cnblogs.com/coco1s/p/7197662.html)

------

HTML：

```html
<div class="container">
    <div class="wave"></div>
</div>
```

SCSS：

```scss
.container {
    position: absolute;
    width: 200px;
    height: 200px;
    padding: 5px;
    border: 5px solid rgb(118, 218, 255);
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    overflow: hidden;
}
.wave {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: rgb(118, 218, 255);
    border-radius: 50%;
 
    &::before,
    &::after{
        content: "";
        position: absolute;
        width: 400px;
        height: 400px;
        top: 0;
        left: 50%;
        background-color: rgba(255, 255, 255, .4);
        border-radius: 45%;
        transform: translate(-50%, -70%) rotate(0);
        animation: rotate 6s linear infinite;
        z-index: 10;
    }
    
    &::after {
        border-radius: 47%;
        background-color: rgba(255, 255, 255, .9);
        transform: translate(-50%, -70%) rotate(0);
        animation: rotate 10s linear -5s infinite;
        z-index: 20;
    }
}

@keyframes rotate {
    50% {
        transform: translate(-50%, -73%) rotate(180deg);
    } 100% {
        transform: translate(-50%, -70%) rotate(360deg);
    }
}
```

## 活用 border-radius, 实现波浪动画

活用 border-radius, 实现波浪动画。

### 关键点

- 利用 border-radius 生成椭圆
- 并不是利用旋转的椭圆本身生成波浪效果，而是利用它去切割背景，产生波浪的效果。

详见：[纯 CSS 实现波浪效果！](https://www.cnblogs.com/coco1s/p/7197662.html)

------

HTML：

```html
<h2>Pure Css Wave</h2>
```

SCSS：

```scss
body {
    position: relative;
    align-items: center;
    min-height: 100vh;
    background-color: rgb(118, 218, 255);
    overflow: hidden;

    &:before, &:after {
        content: "";
        position: absolute;
        left: 50%;
        min-width: 300vw;
        min-height: 300vw;
        background-color: #fff;
        animation-name: rotate;
        animation-iteration-count: infinite;
        animation-timing-function: linear;
    }

    &:before {
        bottom: 15vh;
        border-radius: 45%;
        animation-duration: 10s;
    }

    &:after {
        bottom: 12vh;
        opacity: .5;
        border-radius: 47%;
        animation-duration: 10s;
    }
}

@keyframes rotate {
    0% {
        transform: translate(-50%, 0) rotateZ(0deg);
    }
    50% {
        transform: translate(-50%, -2%) rotateZ(180deg);
    }
    100% {
        transform: translate(-50%, 0%) rotateZ(360deg);
    }
}

h2 {
    position: relative;
    color: #333;
    z-index: 10;
    text-align: center;
    height: 100vh;
    line-height: 140vh;
    font-size: 8vw;
    text-shadow: 3px 3px 2px #999;
}
```

## 使用 background-attachment 实现毛玻璃效果

使用 background-attachment，filter: blur() 实现毛玻璃效果。

毛玻璃效果的重点在于，需要虚化的底图部分是会随页面 resize 变换而变换的。

`background-attachment:fixed` 则可以完美契合这一需求。

### 关键点

`background-attachment` 算是一个比较生僻的属性，基本上平时写业务样式都用不到这个属性。但是它本身很有意思。

`background-attachment`：如果指定了 `background-image` ，那么 `background-attachment` 决定背景是在视口中固定的还是随着包含它的区块滚动的。

### [background-attachment: fixed](https://chokcoco.github.io/CSS-Inspiration/#/./background/bg-attachment-frosted-glass?id=background-attachment-fixed)

**fixed** 此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。

HTML：

```html
<div>
    <p>使用 <br />background-attachment: fixed <br />filter: bulr() <br />实现毛玻璃效果</p>
</div>
```

SCSS：

```scss
$img: 'https://images.unsplash.com/photo-1440688807730-73e4e2169fb8?dpr=1&auto=format&fit=crop&w=1500&h=1001&q=80&cs=tinysrgb&crop=';

html,
body {
    width: 100%;
    height: 100%;
    background-image: url($img);
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-size: cover;
    background-position: top;
    overflow: hidden;
}

div {
    position: relative;
    width: 30vw;
    height: 40vh;
    background: inherit;
    margin: 50px auto;
    padding: 5vmin;
    border-radius: 5px;
    border: 2px solid rgba(255, 255, 255, .5);
    // transform: translate(-50%, -50%);
    // left: 50%;
    // top: 50%;
    
    p {
        position: relative;
        color: #000;
        z-index: 10;
        font-size: 24px;
        line-height: 1.5;
        
    }
    
    &::after {
        position: absolute;
        content: "";
        background: inherit; 
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        filter: blur(10px);
        z-index: 0;
    }
}
```

## 使用 background-attachment 实现滚动阴影

这里，我们借助 `background-attachment: srcoll` 和 `background-attachment: local` 两个属性，在滚动初始的时候，利用两层背景叠加在一起隐藏阴影背景，真正滚动的时候，将叠加的部分移走，只漏出阴影部分即可。

详见这篇文章：[使用纯 CSS 实现滚动阴影效果](https://juejin.cn/post/6913725602428600334)

HTML：

```html
<div class="g-table">
    <table>
        <thead>
            <tr>
                <th>日期</th>
                <th>姓名</th>
                <th>地址</th>
            </tr>    
        </thead>
    </table>
    <div class="g-scroll">
        <table>
            <tbody>
                <tr>
                    <td>2021-01-01</td>
                    <td>XXXXX</td>
                    <td>DDDDD</td>
                </tr>    
            </tbody>
        </table>
    </div>
</div>
```

SCSS：

```scss
.g-table {
    margin: 50px auto;
    width: 450px;
}

table {
    position: relative;
    width: 450px;
    border: 1px solid #ccc;
    text-align: center;
    
    tbody {
        border-collapse: separate;
        height: 200px;
    }
    
    td, th {
        width: 150px;
        padding: 5px;
        border: 1px solid #ccc;
    }
}

.g-scroll {
    top: -1px;
    position: relative;
    height: 200px;
    overflow-y: scroll;
    overflow-x: hidden;
    background: 
        linear-gradient(#fff, transparent) top / 100% 100px,
        radial-gradient(at 50% -15px, rgba(0, 0, 0, .8), transparent 70%) top / 100000% 12px;
    background-repeat: no-repeat;
    background-attachment: local, scroll;
}
```

## background-clip 实现流光文字效果

使用 `background-clip: text` 实现流光文字效果。

### 关键点

背景中有个属性为 background-clip， 其作用就是设置元素的背景（背景图片或颜色）的填充规则。

与 box-sizing 的取值非常类似，通常而言，它有 3 个取值，border-box，padding-box，content-box，后面规范新增了一个 background-clip。时至今日，部分浏览器仍需要添加前缀 webkit 进行使用 -webkit-background-clip。

使用了这个属性的意思是，以区块内的文字作为裁剪区域向外裁剪，文字的背景即为区块的背景，文字之外的区域都将被裁剪掉。

详细的可以看看这篇文章：[奇思妙想 CSS 文字动画](https://github.com/chokcoco/iCSS/issues/101)

HTML：

```html
<p data-text="Lorem ipsum dolor"> Lorem ipsum dolor </p>
```

SCSS：

```scss
html, body {
    width: 100%;
    height: 100%;
    background-image: radial-gradient(ellipse farthest-side at 40% 0%, #455A64 0%, #263238 60%, #1a2327 100%);
    display: flex;
}

p {
    position: relative;
    margin: auto;
    font-size: 5rem;
    word-spacing: 0.2em;
    display: inline-block;
    line-height: 1;
    white-space: nowrap;
    color: transparent;
    background-color: #E8A95B;
    background-clip: text;
}

p::after {
    content: attr(data-text);
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 5;
    background-image: linear-gradient(120deg, transparent 0%, transparent 6rem, white 11rem, transparent 11.15rem, transparent 15rem, rgba(255, 255, 255, 0.3) 20rem, transparent 25rem, transparent 27rem, rgba(255, 255, 255, 0.6) 32rem, white 33rem, rgba(255, 255, 255, 0.3) 33.15rem, transparent 38rem, transparent 40rem, rgba(255, 255, 255, 0.3) 45rem, transparent 50rem, transparent 100%);
    background-clip: text;
    background-size: 150% 100%;
    background-repeat: no-repeat;
    animation: shine 5s infinite linear;
}

@keyframes shine {
    0% {
        background-position: 50% 0;
    }
    100% {
        background-position: -190% 0;
    }
}
```

## 角向渐变线条 border 效果

### 关键点

- 利用角向渐变 `conic-gradient` 与**遮罩**实现线条 border 效果

HTML：

```html
<div></div>
```

SCSS：

```scss
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

*, *::before, *::after {
    box-sizing: border-box;
}

@keyframes rotate {
    100% {
        transform: rotate(1turn);
    }
}

div {
    position: relative;
    z-index: 0;
    width: 400px;
    height: 300px;
    border-radius: 10px;
    overflow: hidden;
    padding: 2rem;
    
    &::before {
        content: '';
        position: absolute;
        z-index: -2;
        left: -50%;
        top: -50%;
        width: 200%;
        height: 200%;
        background-color: #fff;
        background-repeat: no-repeat;
        background-size: 50% 50%;
        background-position: 0 0;
        background-image: conic-gradient(#399953, #399953);
        animation: rotate 4s linear infinite;
    }
    
    &::after {
        content: '';
        position: absolute;
        z-index: -1;
        left: 6px;
        top: 6px;
        width: calc(100% - 12px);
        height: calc(100% - 12px);
        background: white;
        border-radius: 5px;
        animation: opacityChange 3s infinite alternate;
    }
}

@keyframes opacityChange {
    50% {
        opacity:1;
    }
    100% {
        opacity: .5;
    }
}
```

## 角向渐变实现光影 border 效果

角向渐变实现光影 border 效果。

### 关键点

- 利用角向渐变 `conic-gradient` 与**遮罩**实现光影 border 效果

HTML：

```html
<div class="conic"></div>
<div class="conic conic-demo"></div>
```

SCSS：

```scss
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #000;
}

*, *::before, *::after {
    box-sizing: border-box;
}

@keyframes rotate {
    100% {
        transform: rotate(1turn);
    }
}

.conic {
    position: relative;
    z-index: 0;
    width: 400px;
    height: 300px;
    margin: 20px;
    border-radius: 10px;
    overflow: hidden;
    padding: 2rem;
    
    &::before {
        content: '';
        position: absolute;
        z-index: -2;
        left: -50%;
        top: -50%;
        width: 200%;
        height: 200%;
        background-color: #1a232a;
        background-repeat: no-repeat;
        background-position: 0 0;
        background-image: conic-gradient(transparent, rgba(168, 239, 255, 1), transparent 30%);
        animation: rotate 4s linear infinite;
    }
    
    &::after {
        content: '';
        position: absolute;
        z-index: -1;
        left: 6px;
        top: 6px;
        width: calc(100% - 12px);
        height: calc(100% - 12px);
        background: #000;
        border-radius: 5px;
    }
}

.conic-demo::after {
    animation: opacityChange 5s infinite linear;
}

@keyframes opacityChange {
    50% {
        opacity:.5;
    }
    100% {
        opacity: 1;
    }
}
```

## 角向渐变实现纯 CSS 圆环进度图

角向渐变实现纯 CSS 圆环进度图。

### 关键点

- 利用角向渐变 `conic-gradient` 与**遮罩**实现拖尾的圆环进度条

HTML：

```html
<div class="g-container">
    <div class="g-circle"></div>
</div>
```

SCSS：

```scss
body, html {
    width: 100%;
    height: 100%;
    display: flex;
    background: #333;
}

.g-container {
    position: relative;
    width: 200px;
    height: 200px;
    margin: auto;
    border-radius: 50%;
    box-sizing: border-box;
    border: 6px solid #444;
}
.g-circle {
    position: absolute;
    top: -6px;
    left: -6px;
    bottom: -6px;
    right: -6px;
    border-radius: 50%;
    background: conic-gradient(#fc0 0%, transparent 40%, transparent);
    animation: rotate 3s ease-in-out infinite;
    transition-origin: 50% 50%;
    
    &::before {
        content: "";
        position: absolute;
        top: 6px;
        left: 6px;
        bottom: 6px;
        right: 6px;
        background: #333;
        border-radius: 50%;
        // z-index: 1;
    }
    
    &::after {
        content: "";
        position: absolute;
        width: 12px;
        height: 12px;
        top: 0;
        left: 50%;
        transform: translate(-50%, -3px);
        border-radius: 50%;
        background: #fc0;
        box-shadow: 0 0 4px 2px #fc0;
    }
}

@keyframes rotate {
    100% {
        transform: rotate(-360deg);
    }
}
```

## 角向渐变配合混合模式实现炫酷光影效果

角向渐变配合混合模式实现炫酷光影效果。

角向渐变，又叫角向渐变，属于正在路上的标准，具体的，可以看看我的这篇文章：

神奇的 conic-gradient 角向渐变

HTML：

```html
<div></div>
```

SCSS：

```scss
@function randomNum($max, $min: 0, $u: 1) {
    @return ($min + random($max)) * $u;
}

@function randomConicGradient() {
    $n: 16 + random(16);
    $list: ();
    
    @for $i from 0 to $n {
        $list: $list, rgba(hsl(100, randomNum(250, 5, 10%), randomNum(1, 1, 1%)), randomNum(100, 0, .01));
    }
        
    @return conic-gradient($list, nth($list, 1));
}

div {
    width: 100vw;
    height: 100vh;
    margin: 0;
    background: 
        radial-gradient(hsl(9, randomNum(100, 75, 1%), randomNum(100, 75%, 1%)), black);
    
    &:before, &:after {
        position: absolute;
        top: 50%; left: 50%;
        margin: -100vmax; 
        width: 200vmax; 
        height: 200vmax;
        opacity: .5;
        mix-blend-mode: overlay;
        animation: rotate randomNum(100, 25, .1s) ease-in-out infinite;
        content: '';
    }
    
    &:before { background: randomConicGradient(); }
    &:after {
        background: randomConicGradient();
        animation-duration: randomNum(100, 25, .1s);
        animation-direction: reverse;
    }
}

@keyframes rotate { 
    to { 
        transform: rotate(1turn); 
    } 
}
```

上面效果，使用了角向渐变 polyfill JS 库：

- https://cdnjs.cloudflare.com/ajax/libs/prefixfree/1.0.7/prefixfree.min.js
- https://leaverou.github.io/conic-gradient/conic-gradient.js

## 线性渐变线条 border 效果

线性渐变线条 border 效果。

### 关键点

- 利用线性渐变 `conic-gradient` 与**遮罩**实现线条 border 效果

> 这里利用角向渐变也是可以的。

HTML：

```html
<div></div>
```

SCSS：

```scss
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

*, *::before, *::after {
    box-sizing: border-box;
}

@keyframes rotate {
    100% {
        transform: rotate(1turn);
    }
}

.rainbow {
    position: relative;
    z-index: 0;
    width: 400px;
    height: 300px;
    border-radius: 10px;
    overflow: hidden;
    padding: 2rem;
    
    &::before {
        content: '';
        position: absolute;
        z-index: -2;
        left: -50%;
        top: -50%;
        width: 200%;
        height: 200%;
        background-color: #399953;
        background-repeat: no-repeat;
        background-size: 50% 50%, 50% 50%;
        background-position: 0 0, 100% 0, 100% 100%, 0 100%;
        background-image: linear-gradient(#399953, #399953), linear-gradient(#fbb300, #fbb300), linear-gradient(#d53e33, #d53e33), linear-gradient(#377af5, #377af5);
        animation: rotate 4s linear infinite;
    }
    
    &::after {
        content: '';
        position: absolute;
        z-index: -1;
        left: 6px;
        top: 6px;
        width: calc(100% - 12px);
        height: calc(100% - 12px);
        background: white;
        border-radius: 5px;
        animation: opacityChange 3s infinite alternate;
    }
}

@keyframes opacityChange {
    50% {
        opacity:1;
    }
    100% {
        opacity: .5;
    }
}
```

## 线性渐变模拟进度条运动

使用线性渐变模拟进度条运动。

### 知识点

核心难点在于动画的首尾如何衔接上，需要自己尝试计算。

HTML：

```html
<div class="bar"></div>
<div class="bar overflow"></div>
```

SCSS：

```scss
html,
body {
    width: 100%;
    height: 100%;
    display: flex;
}

.bar {
    position: relative;
    width: 400px;
    height: 30px;
    margin: auto;
    border-radius:20px;
    // border: 1px solid #000;
    background: #ffba01;
    
    &::before {
        position: absolute;
        content: "";
        top: 0;
        left: 0;
        width: 400px;
        height: 85px;
        background: repeating-linear-gradient(45deg, #f06a0e, #f06a0e
10px, transparent 11px, transparent 19px, #f06a0e 20px);
        background-position: 0 0;
        background-repeat: no-repeat;
        animation: move 1s linear infinite;
    }
    
}

.overflow {
    overflow: hidden;
}

@keyframes move {
    from { background-position: 0 0; }
    to { background-position: 0 -56px; }
}
```

## 线性渐变实现滚动进度条

使用线性渐变实现滚动进度条。

滚动下面的页面，你会看到顶部实现了进度条的效果，这里其实是个简单的利用了线性渐变的障眼法。

具体可以看看这篇文章：

[不可思议的纯 CSS 滚动进度条效果](https://github.com/chokcoco/iCSS/issues/43)

HTML：

```html
<h1>不可思议的纯 CSS 进度条效果</h1>

....

<p>OK，继续。这个效......</p>
```

SCSS：

```scss
body {
    position: relative;
    padding: 50px;
    font-size: 24px;
    line-height: 30px;
    background-image: linear-gradient(to right top, #ffcc00 50%, #eee 50%);
    background-size: 100% calc(100% - 100vh + 5px);
    background-repeat: no-repeat;
    z-index: 1;
}

body::after {
    content: "";
    position: fixed;
    top: 5px;
    left: 0;
    bottom: 0;
    right: 0;
    background: #fff;
    z-index: -1;
}


/**
 * Unrelated css
 */

h1 {
    font-size: 32px;
    line-height: 60px;
}

ul {
    margin-top: 30px;
}

p {
    font-size: 24px;
    line-height: 30px;
    margin-top: 30px;
}
```

## 线性渐变实现下划线

利用线性渐变实现下划线。与传统下划线相比，渐变实现的下划线有更多的可操控性。

- 可控下划线距离底部的距离
- 可控下划线的粗细
- 可控下划线的颜色
- 可添加动画&渐变

HTML：

```html
<hgroup class="underline">
    <h1 class="underline1-ajkps">.underline1-ajkpys</h1>
    <h1 class="underline2-ajkps">.underline2-ajkpys</h1>
    <h1 class="underline3-ajkps">.underline3-ajkpys</h1>
</hgroup>
```

SCSS：

```scss
.underline {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    height: 200px;
    text-align: center;
    color: white;
    font-size: 200%;
    background: #00aabb;
    border-radius: 0.5em;
}

.underline1-ajkps,
.underline2-ajkps,
.underline3-ajkps {
    height: 100px;
    cursor: pointer;
    position: absolute;
    left: 16%;
    text-shadow: 0.1em 0 #00aabb, -0.1em 0 #00aabb;
    transition: 1s;
}

.underline1-ajkps {
    top: 10%;
    background: linear-gradient(white, white) no-repeat;
    background-size: 100% 1px;
    background-position: -10em 1.15em;
}

.underline1-ajkps:hover {
    background-position: 0 1.15em;
}

.underline2-ajkps {
    top: 38%;
    background: linear-gradient(90deg, white 50%, transparent 0) repeat-x;
    background-size: 0.2em 2px;
    background-position: -3em 1.15em;
}

.underline2-ajkps:hover {
    background-position: 0 1.15em;
}

.underline3-ajkps {
    top: 66%;
    background: 
        linear-gradient(-45deg, transparent 40%, white 0, white 60%, transparent 0) 0 1em,
        linear-gradient(45deg, transparent 40%, white 0, white 60%, transparent 0) 0.1em 1em;
    background-repeat: repeat-x;
    background-size: 0.15em 0.1em;
    background-position: -3em 1.15em;
}
.underline3-ajkps:hover {
    background: linear-gradient(-45deg, transparent 40%, deeppink 0, deeppink 60%, transparent 0) 0 1em,
        linear-gradient(45deg, transparent 40%, deeppink 0, deeppink 60%, transparent 0) 0.1em 1em;
    background-repeat: repeat-x;
    background-size: 0.15em 0.1em;
    background-position: 0 1.15em;
}
```

## 使用多重背景单标签实现气泡按钮点击效果

使用多重背景单标签实现气泡按钮点击效果

### 关键点

- 通过多重背景实现（radial-gradient），并用 animation 改变 background-position。

HTML：

```html
<button class="bubbly-button">Click me!</button>
```

SCSS：

```scss
$fuschia: #ff0081;
$button-bg: $fuschia;
$button-text-color: #fff;
$baby-blue: #f8faff;

body{
  font-size: 16px;
  font-family: 'Helvetica', 'Arial', sans-serif;
  text-align: center;
  background-color: $baby-blue;
}
.bubbly-button{
  font-family: 'Helvetica', 'Arial', sans-serif;
  display: inline-block;
  font-size: 1em;
  padding: 1em 2em;
  margin-top: 100px;
  margin-bottom: 60px;
  -webkit-appearance: none;
  appearance: none;
  background-color: $button-bg;
  color: $button-text-color;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  position: relative;
  transition: transform ease-in 0.1s, box-shadow ease-in 0.25s;
  box-shadow: 0 2px 25px rgba(255, 0, 130, 0.5);
  
  &:focus {
    outline: 0;
  }
  
  &:before, &:after{
    position: absolute;
    content: '';
    display: block;
    width: 140%;
    height: 100%;
    left: -20%;
    z-index: -1000;
    transition: all ease-in-out 0.5s;
    background-repeat: no-repeat;
  }
  
  &:before{
    display: none;
    top: -75%;
    background-image:  
      radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle,  transparent 20%, $button-bg 20%, transparent 30%),
    radial-gradient(circle, $button-bg 20%, transparent 20%), 
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle,  transparent 10%, $button-bg 15%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%);
  background-size: 10% 10%, 20% 20%, 15% 15%, 20% 20%, 18% 18%, 10% 10%, 15% 15%, 10% 10%, 18% 18%;
  //background-position: 0% 80%, -5% 20%, 10% 40%, 20% 0%, 30% 30%, 22% 50%, 50% 50%, 65% 20%, 85% 30%;
  }
  
  &:after{
    display: none;
    bottom: -75%;
    background-image:  
    radial-gradient(circle, $button-bg 20%, transparent 20%), 
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle,  transparent 10%, $button-bg 15%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%),
    radial-gradient(circle, $button-bg 20%, transparent 20%);
  background-size: 15% 15%, 20% 20%, 18% 18%, 20% 20%, 15% 15%, 10% 10%, 20% 20%;
  //background-position: 5% 90%, 10% 90%, 10% 90%, 15% 90%, 25% 90%, 25% 90%, 40% 90%, 55% 90%, 70% 90%;
  }
 
  &:active{
    transform: scale(0.9);
    background-color: darken($button-bg, 5%);
    box-shadow: 0 2px 25px rgba(255, 0, 130, 0.2);
  }
  
  &.animate{
    &:before{
      display: block;
      animation: topBubbles ease-in-out 0.75s forwards;
    }
    &:after{
      display: block;
      animation: bottomBubbles ease-in-out 0.75s forwards;
    }
  }
}


@keyframes topBubbles {
  0%{
    background-position: 5% 90%, 10% 90%, 10% 90%, 15% 90%, 25% 90%, 25% 90%, 40% 90%, 55% 90%, 70% 90%;
  }
    50% {
      background-position: 0% 80%, 0% 20%, 10% 40%, 20% 0%, 30% 30%, 22% 50%, 50% 50%, 65% 20%, 90% 30%;}
 100% {
    background-position: 0% 70%, 0% 10%, 10% 30%, 20% -10%, 30% 20%, 22% 40%, 50% 40%, 65% 10%, 90% 20%;
  background-size: 0% 0%, 0% 0%,  0% 0%,  0% 0%,  0% 0%,  0% 0%;
  }
}

@keyframes bottomBubbles {
  0%{
    background-position: 10% -10%, 30% 10%, 55% -10%, 70% -10%, 85% -10%, 70% -10%, 70% 0%;
  }
  50% {
    background-position: 0% 80%, 20% 80%, 45% 60%, 60% 100%, 75% 70%, 95% 60%, 105% 0%;}
 100% {
    background-position: 0% 90%, 20% 90%, 45% 70%, 60% 110%, 75% 80%, 95% 70%, 110% 10%;
  background-size: 0% 0%, 0% 0%,  0% 0%,  0% 0%,  0% 0%,  0% 0%;
  }
}
```

## 径向渐变实现舞台灯光聚焦效果

使用渐变实现舞台灯光聚焦效果。

### 关键点

- 利用径向渐变生成一个从透明到黑色蒙板的占据整个屏幕的渐变
- 为了让中心聚焦处可移动动画，整个渐变的容器需要比屏幕更大

HTML：

```html
<div class="radial-circle"></div>
```

SCSS：

```scss
$img: 'https://images.unsplash.com/photo-1440688807730-73e4e2169fb8?dpr=1&auto=format&fit=crop&w=1500&h=1001&q=80&cs=tinysrgb&crop=';

html,
body {
    width: 100%;
    height: 100%;
    background-image: url($img);
    background-repeat: no-repeat;
    background-size: cover;
    overflow: hidden;
}

.radial-circle {
    position: absolute;
    top: -100%;
    left: -100%;
    right: -100%;
    bottom: -100%;
    background: radial-gradient(circle at 50% 50%, transparent 0%, transparent 3%, rgba(0, 0, 0, .7) 3.5%, rgba(0, 0, 0, .8) 100%);
    animation: move 10s infinite alternate;
}

@keyframes move {
    0% {
        transform: translateX(-10%);
    }
    100% {
        transform: translateX(10%);
    }
}
```

## 渐变实现波浪边框

渐变实现波浪边框。

### 关键点

- 利用多重线性渐变及单个元素可以设置多层渐变叠加实现

HTML：

```html
<body></body>
```

SCSS：

```scss
body {
    position: relative;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(180deg, #607d8b, #673ab7);
    background-size: 100% 50px;
    background-repeat: no-repeat;
    
    &::before {
          content: "";
          position: absolute;
          left: 0;
          top: 40px;
          right: 0;
          background-repeat: repeat-x;
          height: 10px;
          background-size: 20px 20px;
          background-image: radial-gradient(circle at 10px -5px, transparent 12px, #fff 13px, #fff 20px);
    }
    
    &::after {
          content: "";
          position: absolute;
          left: 0;
          top: 35px;
          right: 0;
          background-repeat: repeat-x;
          height: 15px;
          background-size: 40px 20px;
          background-image: radial-gradient(circle at 10px 15px, white 12px, transparent 13px);
    }
}
```

## 使用 mix-blend-mode 实现抖音 LOGO

使用 mix-blend-mode 实现抖音 LOGO。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### 关键点

- 主要借助伪元素实现了整体 J 结构，借助了 mix-blend-mode 实现融合效果
- 利用 `mix-blend-mode: lighten` 混合模式实现两个 J 形结构重叠部分为白色

HTML：

```html
<div class="g-container">
    <div class="j"></div>
    <div class="j"></div>
</div>
```

SCSS：

```scss
body {
    background: #000;
    overflow: hidden;
}

.g-container {
    position: relative;
    width: 200px;
    margin: 100px auto;
    filter: contrast(150%) brightness(110%);
}

.j {
    position: absolute;
    top: 0;
    left: 0;
    width: 47px;
    height: 218px;
    z-index: 1;
    background: #24f6f0;

    &::before {
        content: "";
        position: absolute;
        width: 100px;
        height: 100px;
        border: 47px solid #24f6f0;
        border-top: 47px solid transparent;
        border-radius: 50%;
        top: 121px;
        left: -147px;
        transform: rotate(45deg);
    }
    
        &::after {
        content: "";
        position: absolute;
        width: 140px;
        height: 140px;
        border: 40px solid #24f6f0;
        border-right: 40px solid transparent;
        border-top: 40px solid transparent;
        border-left: 40px solid transparent;
        top: -110px;
        right: -183px;
        border-radius: 100%;
        transform: rotate(45deg);
        z-index: -10;
    }
}

.j:last-child {
    left: 10px;
    top: 10px;
    background: #fe2d52;
    z-index: 100;
    mix-blend-mode: lighten;
    animation: moveLeft 10s infinite;
    
    &::before {
        border: 47px solid #fe2d52;
        border-top: 47px solid transparent;

    }
    &::after {
        border: 40px solid #fe2d52;
        border-right: 40px solid transparent;
        border-top: 40px solid transparent;
        border-left: 40px solid transparent;
    }
}

@keyframes moveLeft {
    0% {
        transform: translate(200px);
    }
    50% {
        transform: translate(0px);
    }
    100% {
        transform: translate(0px);
    }
}
```

## mix-blend-mode 实现 loading 效果

mix-blend-mode 实现 loading 效果。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### 关键点

这里使用了 `mix-blend-mode: screen` 滤色模式，这是一种提亮图像形混合模式。滤色的英文是 screen，也就是两个颜色同时投影到一个屏幕上的合成颜色。具体做法是把两个颜色都反相，相乘，然后再反相。简单记忆为"让白更白，而黑不变"。（不一定十分准确，如有错误还请指正）

我们将几个 div 按照不同延时(animation-delay)小幅度旋转起来，来达到一种很显眼很魔性的效果，适合做 loading 图。

HTML：

```html
<strong class="loading">
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
    <span></span>
</strong>
```

SCSS：

```scss
body {
    background:#291f34;
    overflow:hidden;
}

.loading {
    position:absolute;
    left:50%;
    top:30vh;
    margin-left:-20vh;
    display:block;
    width:40vh;
    height:40vh;
    text-align:center;
    filter:contrast(1.2);
    
    span {
          mix-blend-mode:screen;
        display:block;
        position:absolute;
        border-radius:50%;
        animation:wave 3s infinite linear;
    }
    
    span:nth-child(0) {
        left:-11%;
        right:-2%;
        top:-12%;
        bottom:-5%;
        transform-origin:46% 53%;
        animation-delay:0;
        background-color:hsl(0, 50%, 50%);
    }
    
    span:nth-child(1) {
        left:-4%;
        right:-4%;
        top:-9%;
        bottom:-2%;
        transform-origin:47% 50%;
        animation-delay:-1s;
        background-color:hsl(50, 60%, 50%);
    }
    
    span:nth-child(2) {
        left:-11%;
        right:-4%;
        top:-10%;
        bottom:-11%;
        transform-origin:49% 53%;
        animation-delay:-1.5s;
        background-color:hsl(100, 70%, 50%);
    }
    
    span:nth-child(3) {
        left:-7%;
        right:-9%;
        top:-11%;
        bottom:-4%;
        transform-origin:47% 52%;
        animation-delay:-2s;
        background-color:hsl(150, 80%, 50%);
    }
    
    span:nth-child(4) {
        left:-8%;
        right:-3%;
        top:-5%;
        bottom:-11%;
        transform-origin:47% 52%;
        animation-delay:-2.5s;
        background-color:hsl(200, 90%, 50%);
    }
    
    span:nth-child(5) {
        left:-10%;
        right:-8%;
        top:-4%;
        bottom:-9%;
        transform-origin:48% 51%;
        animation-delay:-3s;
        background-color:hsl(250, 100%, 50%);
    }
    
    span:nth-child(6) {
        left:-9%;
        right:-11%;
        top:-5%;
        bottom:-8%;
        transform-origin:47% 50%;
        animation-delay:-3.5s;
        background-color:hsl(300, 100%, 50%);
    }
}

@keyframes wave {
    from {
        transform:rotateZ(0deg);
    }
    to {
        transform:rotateZ(360deg);
    }
}
```

## 图片的类抖音 LOGO 晕眩效果

使用 background-blend-mode | mix-blend-mode 实现类抖音LOGO晕眩效果。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### mix-blend-mode

除了 `mix-blend-mode` ，CSS 还提供一个 `background-blend-mode` 。也就是背景的混合模式。

- 可以是背景图片与背景图片的混合，
- 也可以是背景图片和背景色的之间的混合。

### 关键点

本例是 `background-blend-mode` | `mix-blend-mode` 是配合使用。

HTML：

```html
<div class="mix3d"></div>
```

SCSS：

```scss
.mix3d {
    margin: 30px auto 0;
    width: 400px;
    height: 400px;
    z-index: 2;
    background: url('https://yyb.gtimg.com/aiplat/page/product/visionimgidy/img/demo6-16a47e5d31.jpg?max_age=31536000'), cyan;
    background-blend-mode: lighten;
    background-size: center;

  &:after {
    content: '';
    position: absolute;
    width: 400px;
    height: 400px;
    z-index: 3;
    background: url('https://yyb.gtimg.com/aiplat/page/product/visionimgidy/img/demo6-16a47e5d31.jpg?max_age=31536000'), red;
    background-blend-mode: lighten;
    margin-left: 10px;
    background-size: center;
    mix-blend-mode: darken;
  }
}
```

## mix-blend-mode MIX

使用 background-blend-mode | mix-blend-mode 可以实现很多很有意思的动画融合效果。

当然，也可以搭配 filter 中的 blur 和 contrast。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### mix-blend-mode

除了 `mix-blend-mode` ，CSS 还提供一个 `background-blend-mode` 。也就是背景的混合模式。

- 可以是背景图片与背景图片的混合，
- 也可以是背景图片和背景色的之间的混合。

利用混合模式，我们可以尽情发挥想象。

### Demo MIX 1

HTML：

```pug
.container
    .top
        - for (i = 0; i < 60; i++)
            .top_ball
                .ball
    .left
        - for (i = 0; i < 60; i++)
            .top_ball
                .ball
    .right
        - for (i = 0; i < 60; i++)
            .top_ball
                .ball
```

SCSS：

```scss
$count: 60;

@function setBorderRadius() {
    $pattern1: random(80) + 20;
    $pattern2: 100 - $pattern1;
    $pattern3: random(80) + 20;
    $pattern4: 100 - $pattern3;
    $pattern5: random(80) + 20;
    $pattern6: 100 - $pattern5;
    $pattern7: random(80) + 20;
    $pattern8: 100 - $pattern7;
    
    @return (#{$pattern3 + 0%} #{$pattern4 + 0%} #{$pattern1 + 0%} #{$pattern2 +
        0%} / #{$pattern5 + 0%} #{$pattern7 + 0%} #{$pattern8 + 0%} #{$pattern6 +
        0%});
}

html, body {
    width: 100%;
    height: 100%;
    background: #000;
}

.container {
    width: 100%;
    height: 100%;
    overflow: hidden;
    filter: blur(3px) contrast(500) hue-rotate(50deg);
    animation: filterChange 10s infinite alternate;
}

.ball {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 50%;
    height: 50%;
    transform: translate(-50%, -50%);
    background: #fff;
    border-radius: setBorderRadius();
    mix-blend-mode: screen;
}

.top,
.left,
.right{
    position: absolute;
    width: 20vmin;
    height: 20vmin;
    
    @for $i from 1 through $count {
        .top_ball:nth-child(#{$i}) {
            $size: random(15) + 5vmin;
            $opacity: random(100) / 100;
            position: absolute;
            top: 50%;
            left: 50;
            transform: translate(-50%, -50%);
            width: $size;
            height: $size;
            border-radius: setBorderRadius();
            background: rgba(random(255), random(255), random(255), $opacity);
        }
    }
}

.top {
    top: 10vh;
    left: 50vw;
    
    @for $i from 1 through $count {
        .top_ball:nth-child(#{$i}) {
            animation: rotate random(5000) + 1000ms infinite (200 * $i * -1ms) alternate;
        }
    }
}

.left {
    top: 70vh;
    left: 35vw;
    
    @for $i from 1 through $count {
        .top_ball:nth-child(#{$i}) {
            animation: rotateLeft random(5000) + 1000ms infinite (200 * $i * -1ms) alternate;
        }
    }
}

.right {
    top: 70vh;
    left: 65vw;
    
    @for $i from 1 through $count {
        .top_ball:nth-child(#{$i}) {
            animation: rotateRight random(5000) + 1000ms infinite (200 * $i * -1ms) alternate;
        }
    }
}


@keyframes rotate {
  0% {
    transform: translate(-50%, -50%) rotate(-360deg);
  }

  100% {
    transform: translate(calc(-50% - 15vw), calc(-50% + 60vh)) rotate(360deg);
  }
}

@keyframes rotateLeft {
  0% {
    transform: translate(-50%, -50%) rotate(-360deg);
  }

  100% {
    transform: translate(calc(-50% + 30vw), -50%) rotate(360deg);
  }
}

@keyframes rotateRight {
  0% {
    transform: translate(-50%, -50%) rotate(-360deg);
  }

  100% {
    transform: translate(calc(-50% - 15vw), calc(-50% - 60vh)) rotate(360deg);
  }
}

@keyframes filterChange {
    100% {
        filter: blur(15px) contrast(10) hue-rotate(10deg);
    }
}
```

### Demo MIX2

HTML：

```HTML
<div></div>
```

SCSS：

```scss
html,
body {
    overflow: hidden;
    // filter: blur(2px) contrast(3) hue-rotate(-20deg);
}

body::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, #9c27b0, #ffc107, #fdf5cf, #F44336);
    z-index: 20;
    mix-blend-mode: color-burn;
}

body::after {
    content: "";
    position: absolute;
    top: -200%;
    left: 0;
    right: 0;
    bottom: -200%;
    background: radial-gradient(circle at 35% 75%, #000, #fff, #333, #ccc, #666, #aaa);
    background-size: 25% 25%;
    animation: rotate 10s infinite linear;
    z-index: 10;
    mix-blend-mode: color-dodge;
}

div {
    width: 200vw;
    height: 200vh;
    background: radial-gradient(circle at 50% 50%, #fff, #333, #ccc, #666, #aaa, #000);
    background-size: 30% 25%;
    animation: move 10s infinite linear alternate;
}

@keyframes move {
    100% {
        transform: translate(-100vw, 0);
    }
}

@keyframes rotate {
    100% {
        transform: rotate(360deg);
    }
}
```

### Demo MIX3

HTML：

```pug
.container
    -for(var i=0; i<8; i++)
        .circle
```

SCSS：

```scss
$n: 8;

@function randomColor() {
    @return rgba(random(255), random(255), random(255), 1);
}

html,
body {
    width: 100%;
    height: 100%;
    background: #000;
}

.container {
    position: absolute;
    width: 300px;
    height: 300px;
    top: 80%;
    left: 50%;
    transform: translate(-50%, -50%);
    // mix-blend-mode: color-dodge;
    // background-blend-mode: color-dodge;
}

.circle {
    position: absolute;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    mix-blend-mode: color-dodge;
    top: 0;
    left: 0;
    will-change: transform;
    background: #fff;
}

@for $i from 1 through $n {
    .circle:nth-child(#{$i}) {
        background: radial-gradient(randomColor() 15%, randomColor() 30%, randomColor() 45%, randomColor() 60%, randomColor() 75%, randomColor() 90%, randomColor() 100%);
        transform: rotate($i * 45deg) translate3d(0, 0, 0);
        animation: move-#{$i} 15s infinite 2s ease-in-out;
    }
    
    @keyframes move-#{$i} {
        10% { transform: rotate($i * 45deg) translate3d(120px, 0, 0) rotateZ(90deg); }
        20% { transform: rotate($i * 90deg) translate3d(50px, 0, 0) rotateY(90deg); }
        30% { transform: rotate($i * 180deg) translate3d(125px, 0, 0) rotateY(180deg); }
        40% { transform: rotate($i * 135deg) translate3d(50px, 0, 0) rotateX(180deg); }
        50% { transform: rotate($i * 45deg) translate3d(100px, 0, 0) rotateX(180deg); }
        60% { transform: rotate($i * 405deg) translate3d(10px, -20px, 0) rotateX(90deg) rotateY(180deg); }
        70% { transform: rotate($i * -45deg) translate3d(120px, 50px, 0) rotateY(0deg); }
        80% { transform: rotate($i * 90deg) translate3d(50px, 0, 0) rotateY(180deg); }
        90% { transform: rotate($i * 45deg) translate3d(150px, -20px, 0) rotateX(180deg);}
        100% { transform: rotate($i * 45deg) translate3d(0, 0, 0); }
    }
}
```

## 类抖音 LOGO 文字故障效果

使用 mix-blend-mode 实现类抖音 LOGO 文字故障效果。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### 关键点

- 利用 `mix-blend-mode: lighten` 混合模式实现两段文字结构重叠部分为白色
- 利用元素位移完成错位移动动画，形成视觉上的冲击效果

HTML：

```html
<div class="text-magic" data-word="CSSTextGlitch">
    <div class="white"></div>
</div>
```

SCSS：

```scss
.text-magic {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(3);
    width: 300px;
    font-size: 36px;
    font-family: Raleway, Verdana, Arial;
    color: transparent;
}
.white {
    position: absolute;
    left: -10px;
    width: 100%;
    height: 1px;
    background: #000;
    z-index: 4;
    animation: whiteMove 10s ease-out infinite;
}

.text-magic::before {
    content: attr(data-word);
    position: absolute;
    top: 0;
    left: 0;
    height: 36px;
    color: red;
    overflow: hidden;
    z-index: 2;
    filter: contrast(200%);
    text-shadow: 1px 0 0 red;
    animation: move 0.95s infinite;
}

.text-magic::after {
    content: attr(data-word);
    position: absolute;
    top: 0;
    left: -1px;
    height: 36px;
    color: rgba(255, 255, 255, 0.8);
    overflow: hidden;
    z-index: 3;
    color: cyan;
    filter: contrast(200%);
    text-shadow: -1px 0 0 cyan;
    mix-blend-mode: lighten;
    animation: move 1.1s infinite 0.2s;
}

@keyframes whiteMove {
    9% {
        top: 38px;
    }
    14% {
        top: 8px;
    }
    18% {
        top: 42px;
    }
    22% {
        top: 1px;
    }
    32% {
        top: 32px;
    }
    34% {
        top: 12px;
    }
    40% {
        top: 26px;
    }
    43% {
        top: 7px;
    }
    99% {
        top: 30px;
    }
}

@keyframes move {
    10% {
        top: -0.4px;
        left: -1.1px;
    }
    20% {
        top: 0.4px;
        left: -0.2px;
    }
    30% {
        left: .5px;
    }
    40% {
        top: -0.3px;
        left: -0.7px;
    }
    50% {
        left: 0.2px;
    }
    60% {
        top: 1.8px;
        left: -1.2px;
    }
    70% {
        top: -1px;
        left: 0.1px;
    }
    80% {
        top: -0.4px;
        left: -0.9px;
    }
    90% {
        left: 1.2px;
    }
    100% {
        left: -1.2px;
    }
}
```

## 使用 mix-blend-mode 实现光影文字效果

使用 mix-blend-mode 实现光影文字效果。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### 关键点

- 利用混合模式 `mix-blend-mode: multiply` 生成渐变色的文字。
- 利用 `mix-blend-mode: color-dodge` 混合模式，给文字加上点缀，实现美妙的光影效果

详细的可以看看这篇文章：[奇思妙想 CSS 文字动画](https://github.com/chokcoco/iCSS/issues/101)

HTML：

```html
<div class="g-container">
    <p>Magic Text</p>
</div>
```

SCSS：

```scss
.g-container {
    margin: auto;
}

p {
    position: relative;
    font-size: 12vw;
    line-height: 16vw;
    // color: #9a9acc;
    overflow: hidden;
    -webkit-text-stroke: 3px #7272a5;

    &::before {
        content: " ";
        width: 100%;
        height: 100%;
        position: absolute;
        left: 0;
        top: 0;
        background-image: linear-gradient(45deg, #ff269b, #2ab5f5, #ffbf00);
        mix-blend-mode: multiply;
    }

    &::after {
        content: "";
        background: radial-gradient(circle, #fff, #000 50%);
        background-size: 25% 25%;
        position: absolute;
        top: -100%;
        left: -100%;
        right: 0;
        bottom: 0;
        mix-blend-mode: color-dodge;
        animation: mix 8s linear infinite;
    }
}

@keyframes mix {
    to {
        transform: translate(50%, 50%);
    }
}
```

## CSS WAVE MOVE(惊艳的水波效果)

使用 mix-blend-mode 实现惊艳的水波效果。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### mix-blend-mode

除了 `mix-blend-mode` ，CSS 还提供一个 `background-blend-mode` 。也就是背景的混合模式。

- 可以是背景图片与背景图片的混合，
- 也可以是背景图片和背景色的之间的混合。

### 关键点

本例是 `background-blend-mode`、`mix-blend-mode` 以及滤镜的配合使用。

HTML：

```html
<div></div>
```

SCSS：

```scss
$circles: ();
$move: ();
$n: 8;

@function randomNum($max, $min: 0, $u: 1) {
    @return ($min + random($max)) * $u;
}

@for $i from 0 through $n {
    $start-x: randomNum(100, 1) * 1vw;
    $start-y: randomNum(100, 1) * 1vh;

    $end-x: randomNum(150, -50) * 1vw;
    $end-y: randomNum(150, -50) * 1vh;

    $circles: append(
        $circles,
        radial-gradient(
                randomNum(75, 25) * 1vw,
                #ddd 0%,
                #666 10%,
                #fff,
                #000,
                #999
            )
            $start-x $start-y,
        comma
    );

    $move: append($move, $end-x $end-y, comma);
}

html,
body {
    width: 100%;
    height: 100%;
    overflow:hidden;
}

div {
    position: absolute;
    top:0;
    left: 0;
    right: 0;
    bottom :0;
    background: $circles;
    animation: waveMove 15s infinite linear alternate;
    background-blend-mode: difference;
    filter: blur(2px) hue-rotate(0);

    &::before {
        content: "";
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background: #03a9f4;
        mix-blend-mode: color-burn;
    }
}

@keyframes waveMove {
    100% {
        background-position: $move;
        filter: blur(5px) hue-rotate(30deg);
    }
}
```

## mix-blend-mode 叠加多重渐变背景

使用 background-blend-mode | mix-blend-mode 可以实现很多很有意思的动画融合效果。

CSS3 新增了一个很有意思的属性 -- `mix-blend-mode` ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。

混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。

### mix-blend-mode

除了 `mix-blend-mode` ，CSS 还提供一个 `background-blend-mode` 。也就是背景的混合模式。

- 可以是背景图片与背景图片的混合，
- 也可以是背景图片和背景色的之间的混合。

利用混合模式，我们可以尽情发挥想象。

### 多重渐变背景配合多重混合模式

原理大致是这样：

![bg5](https://user-images.githubusercontent.com/8554143/100539321-a3c11c80-3270-11eb-89ec-61aff7012be1.gif)

HTML：

```
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
```

SCSS：

```scss
html, body {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    padding-bottom: 100px;
}

div {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
}

div:nth-child(1) {
    background: linear-gradient(
        238deg,
        rgb(130, 255, 0) 0%,
        rgb(0, 84, 166) 100%
    );
    animation: move 12s infinite linear;
}

div:nth-child(2) {
    background: linear-gradient(238deg, rgb(33, 200, 69) 0%, rgb(0, 0, 100) 100%);
    mix-blend-mode: overlay;
    animation: move 6s infinite linear;
}

div:nth-child(3) {
    background: linear-gradient(238deg, rgb(200, 255, 255) 48%, rgb(3, 0, 151) 100%);
    mix-blend-mode: multiply;
    animation: move 6s infinite linear;
}

div:nth-child(4) {
    background: radial-gradient(
        100% 85% at 0% 100%,
        rgb(0, 0, 0) 0%,
        rgb(0, 131, 255) 50%,
        rgb(255, 0, 0) 100%
    );
    mix-blend-mode: difference;
    animation: move 6s infinite linear;
}

div:nth-child(5) {
    background: radial-gradient(
        100% 225% at 0% 100%,
        rgb(255, 0, 0) 0%,
        rgb(66, 255, 0) 100%
    );
    mix-blend-mode: difference;
    animation: move 6s infinite linear;
}

div:nth-child(6) {
    background: radial-gradient(
        100% 140% at 100% 0%,
        rgb(0, 134, 62) 0%,
        rgb(0, 239, 255) 50%,
        rgb(0, 113, 186) 100%
    );
    mix-blend-mode: overlay;
    animation: move 6s infinite linear;
}

@keyframes move {
    0% {
        filter: unset;
    }
    
    100% {
        filter: hue-rotate(360deg);
    }
}
```

## 使用混合模式叠加实现文字波浪效果

使用混合模式叠加实现文字波浪效果

### 关键点

传统的文字镂空展示背景更多的是使用 `background-clip`。

但是本效果文字的背景是动画效果，无法使用 `background-clip` 进行穿透，这里通过混合模式 `mix-blend-mode` 的特性实现。

HTML：

```
<div class="g-container">
    <p>TEXT WAVE</p>
</div>
```

SCSS：

```scss
html, body {
    width: 100%;
    height: 100%;
    display: flex;
}

.g-container {
    margin: auto;
}

p {
    position: relative;
    font-size: 120px;
    font-weight: bold;
    background: #fff;
    color: #000;
    overflow: hidden;
    
    &::before,
    &::after {
        content: "";
        position: absolute;
        top: -923px;
        left: 50%;
        width: 2000px;
        height: 2000px;
        border-radius: 45% 48% 43% 47%;
        transform: translate(-50%, -50%);
        background: rgba(3, 169, 244, .85);
        animation: rotate 10s infinite linear;
        z-index: 1;
        mix-blend-mode: lighten;
    }
    
    &::after {
        border-radius: 43% 47% 44% 48%;
        animation: rotate 10s infinite .5s linear;
    }
}

@keyframes rotate {
    0% {
        transform: translate(-50%, -50%) rotate(0);
    }
    100% {
        transform: translate(-50%, -50%) rotate(360deg);
    }
}
```

## 3D 球动画

3D 球动画。

### 关键点

- 借助 SASS，利用公式，随机将 100 个点附着在球表面，再进行动

HTML：

```pug
// pug模板
.container    
    - for(var i=0; i<100; i++)
        .point
```

SCSS：

```scss
$n: 100;

@function randomNum($max, $min: 0, $u: 1) {
    @return ($min + random($max)) * $u;
}

@function randomColor() {
    @return rgba(randomNum(255), randomNum(255), randomNum(255), randomNum(100)/100);
}

body {
    background: #000;
    overflow: hidden;
}
.container {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 200px;
    height: 200px;
    transform: translate3d(-50%, -50%, 0) rotateY(0deg) rotateZ(0deg);
    transform-style: preserve-3d;
    perspective: 1000;
    animation: fullrotate 10s linear infinite;
    // filter: blur(1px);
}
.point {
    position: absolute;
    top: 95px;
    left: 49%;
    background: #000;
    border-radius: 50%;      
    width: 20px;
    height: 20px;
    // mix-blend-mode: lighten;
    
    @for $i from 1 through $n {        
        $rot-x: random(360) + deg;
        $rot-y: random(360) + deg;
        $radius: 100px;
        
        &:nth-child(#{$i}) {
            transform: rotateY($rot-y) rotateX($rot-x) translateZ($radius);
            background: randomColor();
            filter: blur(0px);
            animation: 
                expand#{$i} 10s linear infinite, 
                sparkle 0.25s linear infinite;
            animation-delay: $i*2ms;
        }
        @keyframes expand#{$i} {
            0% { 
                transform: rotateY($rot-y) rotateX($rot-x) translateZ($radius);
                filter: blur(0px);
                width: 20px;
                height: 20px;
            }
            20%, 40% { 
                transform: rotateY($rot-y) rotateX($rot-x) translateZ($radius*($i/10));
                filter: blur(10px);
                width: 20px;
                height: 20px;
            }
            40%, 60% {
                transform: rotateY($rot-y) rotateX($rot-x) translateZ($radius*4);
                filter: blur(0px);
                width: 40px;
                height: 40px;
            }
            65%, 80% {
                transform: rotateY($rot-y) rotateX($rot-x) translateZ($radius*($i/10));
                filter: blur(10px);
                width: 20px;
                height: 20px;
            }
            85%, 100% {
                transform: rotateY($rot-y) rotateX($rot-x) translateZ($radius);
                filter: blur(0px);
                width: 20px;
                height: 20px;
            }
        }
        @-webkit-keyframes sparkle {
            50% {
                background: lemonchiffon;
            }
        }
    }
}

@keyframes fullrotate {
    to { 
        transform: translate3d(-50%, -50%, 0) rotateY(360deg) rotateZ(360deg);
    }
}
```

## 3D 宇宙时空穿梭效果

利用 CSS 3D 实现星空穿梭效果

### 关键点

1. 选取一张合适的星空图
2. 利用 5 个元素设定上述星空图，在 3D 效果的作用下，在上下左右中5个方向铺满一屏
3. 父容器在极小的 `perspective` 值下，设定容器的 `translateZ`动画，实现效果
4. 通过两组同样的动画，其中一组设置负延迟实现动画的衔接

HTML：

```
<div class="g-container">
  <div class="g-group">
      <div class="item item-right"></div>
      <div class="item item-left"></div>   
      <div class="item item-top"></div>
      <div class="item item-bottom"></div> 
      <div class="item item-middle"></div>    
  </div>
  <div class="g-group">
      <div class="item item-right"></div>
      <div class="item item-left"></div>   
      <div class="item item-top"></div>
      <div class="item item-bottom"></div>   
      <div class="item item-middle"></div>    
  </div>
</div>
```

SCSS：

```scss
html, body{
  height: 100%;
  width: 100%;
  overflow: hidden;
  background: #000;
  text-align: center;
}

body:before{
  content: '';
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}

.g-container{
  display: inline-block;
  vertical-align: middle;
  perspective: 4px;
  perspective-origin: 50% 50%;
  position: relative;
  animation: hueRotate 21s infinite linear;
}

.g-group{
  position: absolute;
/*   perspective: 4px; */
  width: 1000px;
  height: 1000px;
  left: -500px;
  top: -500px;
  transform-style: preserve-3d;
  animation: move 12s infinite linear;
  animation-fill-mode: forwards;
}

.g-group:nth-child(2){
  animation: move 12s infinite linear;
  animation-delay: -6s;
}

.item {
  position: absolute;
  width: 100%;
  height: 100%;
  background: url(https://z3.ax1x.com/2021/08/20/fLwuMd.jpg);
  background-size: cover;
  opacity: 1;
  animation: fade 12s infinite linear;
  animation-delay: 0;
}

.g-group:nth-child(2) .item {
  animation-delay: -6s;
}

.item-right {
  transform: rotateY(90deg) translateZ(500px);
}

.item-left {
  transform: rotateY(-90deg) translateZ(500px);
}

.item-top {
  transform: rotateX(90deg) translateZ(500px);
}

.item-bottom {
  transform: rotateX(-90deg) translateZ(500px);
}

.item-middle {
  transform: rotateX(180deg) translateZ(1000px);
}

@keyframes move {
  0%{
    transform: translateZ(-500px) rotate(0deg);
  }
  100%{
    transform: translateZ(500px) rotate(0deg);
  }
}

@keyframes fade {
  0%{
    opacity: 0;
  }
  25%,
  60%{
    opacity: 1;
  }
  100%{
    opacity: 0;
  }
}

@keyframes hueRotate {
  0% {
    filter: hue-rotate(0);
  }
  100% {
    filter: hue-rotate(360deg);
  }
}
```

## 3D 立方体进度条

使用 CSS 3D 实现的立方体制作酷炫的进度条。

### 关键点

- 可以利用 CSS Property 实现渐变的动画效果
- 可以利用滤镜的 hue-rotate 变化实现整体的颜色变化

HTML：

```
<div class="demo-cube perspective percentage">
  <ul class="cube">
    <li class="top"></li>
    <li class="bottom"></li>
    <li class="front"></li>
    <li class="back"></li>
  </ul>
</div>

<div class="demo-cube perspective colorful">
  <ul class="cube">
    <li class="top"></li>
    <li class="bottom"></li>
    <li class="front"></li>
    <li class="back"></li>
  </ul>
</div>

<div class="demo-cube perspective pink">
  <ul class="cube">
    <li class="top"></li>
    <li class="bottom"></li>
    <li class="front"></li>
    <li class="back"></li>
  </ul>
</div>
```

SCSS：

```scss
@property --per {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 0%;
}

body,
html {
  width: 100%;
  height: 100%;
  background: linear-gradient(0deg, #EEEFED, #F9E3E9);
  display: flex;
  flex-direction: column;
}

.demo-cube {
  margin: auto;
}

.perspective {
  transform-style: preserve-3d;
  perspective: 520px;
  transform: rotateX(15deg);
}

ul {
  padding: 0;
  list-style: none;
}

.demo-cube {
  position: relative;
  width: 100%;
  height: 200px;

  .cube {
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300px;
    height: 100px;
    transform-style: preserve-3d;
    transform-origin: 50px 50px;
    transform: translate(-50%, -50%) rotateX(-33.5deg);

    li {
      position: absolute;
      display: block;
      width: 100px;
      height: 100px;
      // background: rgba(156, 39, 176, .4);
      // border: 1px solid #ddd;
    }
    .top {
      width: 300px;
      transform: rotateX(90deg) translateZ(50px);
    }
    .bottom {
      width: 300px;
      transform: rotateX(-90deg) translateZ(50px);
    }
    .front {
      width: 300px;
      transform: translateZ(50px);
    }
    .back {
      width: 300px;
      transform: rotateX(-180deg) translateZ(50px);
    }
  }
}

.percentage .cube {
  .top,
  .front,
  .bottom,
  .back {
    background: linear-gradient(90deg, rgba(156, 39, 176, .3), rgba(255, 34, 109, .8) 65%, rgba(255, 255, 255, .6) 65%, rgba(255, 255, 255, .6));
  }
}

.colorful {
  animation: hueRotate 10s infinite linear;
  .cube {
    .top,
    .front,
    .bottom,
    .back {
        background: linear-gradient(90deg, rgba(40, 101, 127, .9), rgba(133, 165, 181, .5) 85%, rgba(255, 255, 255, .6) 85%, rgba(255, 255, 255, .6));
    }
  }
}
.pink .cube {
  .top,
  .front,
  .bottom,
  .back {
    background: linear-gradient(90deg, rgba(255, 217, 34, .6), rgba(255, 34, 109, .8) var(--per), rgba(255, 34, 109, .1) var(--per), rgba(255, 34, 109, .1));
    animation: perChange 6s infinite;
  }
}

@keyframes perChange {
  0% {
    --per: 0%;
  }
  90%,
  to {
    --per: 80%;
  }
}

@keyframes hueRotate {
  0% {
    filter: hue-rotate(0);
  }
  100% {
    filter: hue-rotate(360deg);
  }
}
```

## 3D 立方体滚动 404 效果

使用 CSS 3D 实现的立方体制作的一个 404 效果。

### 关键点

其核心就在于在一个 CSS 3D 立方体的基础上：

1. 添加立方体的滚动动画
2. 控制下落的缓动函数，及落地的震荡动画（为了效果更为逼真，运用了设计动画中的预备动作、跟随和重叠动画等技巧）
3. 控制立方体及地面数字画面的平移
4. 控制动画的无限循环

整体制作还是非常有难度的，但是用在自己的 404 页面，确实也是非常的酷炫。这个效果，我最早见于 [Yusuke Nakaya](https://codepen.io/YusukeNakaya) 大神，完整的代码你也可以戳这里：[CodePen -- Only CSS: 404 Rolling Box](https://codepen.io/YusukeNakaya/pen/YLPVER)

HTML（使用了 Pug 模板引擎）：

```
.rail
  - for (i = 0; i < 10; i++)
    .stamp.four 4
    .stamp.zero 0
.world
  .forward
    .box
      - for (i = 0; i < 6; i++)
        .wall
```

SCSS：

```scss
body {
  background: #fff;
  height: 100vh;
  overflow: hidden;
  display: flex;
  font-family: 'Anton', sans-serif;
  justify-content: center;
  align-items: center;
  perspective: 1000px;
}

$wallSize: 200px;

div {
  transform-style: preserve-3d;
}
.rail {
  position: absolute;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  transform: rotateX(-30deg) rotateY(-30deg);
  .stamp {
    position: absolute;
    width: $wallSize;
    height: $wallSize;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(20, 20, 20, 1);
    color: #fff;
    font-size: 7rem;
    @for $i from 1 through 20 {
      &:nth-child(#{$i}) {
        animation: stampSlide 20 * 2000ms ($i * -2000) - 300ms linear infinite;
      }
    }
  }
}
@keyframes stampSlide {
  0% {
    transform: rotateX(90deg) rotateZ(-90deg) translateZ(-$wallSize) translateY(130px);
  }
  100% {
    transform: rotateX(90deg) rotateZ(-90deg) translateZ(-$wallSize) translateY(130 - 200 * 20px);
  }
}
.world {
  transform: rotateX(-30deg) rotateY(-30deg);
  .forward {
    position: absolute;
    animation: slide 2000ms linear infinite;
  }
  .box {
    width: $wallSize;
    height: $wallSize;
    transform-origin: 100% 100%;
    animation: roll 2000ms cubic-bezier(1.000, 0.010, 1.000, 1.000) infinite;
    .wall {
      position: absolute;
      width: $wallSize;
      height: $wallSize;
      background: rgba(10, 10, 10, 0.8);
      border: 1px solid rgba(250, 250, 250, 1);
      box-sizing: border-box;
      &::before {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-size: 7rem;
      }
      &:nth-child(1) {
        transform: translateZ($wallSize / 2);
      }
      &:nth-child(2) {
        transform: rotateX(180deg) translateZ($wallSize / 2);
      }
      &:nth-child(3) {
        transform: rotateX(90deg) translateZ($wallSize / 2);
        &::before {
          transform: rotateX(180deg) rotateZ(90deg) translateZ(-1px);
          animation: zeroFour 4000ms -2000ms linear infinite;
        }
      }
      &:nth-child(4) {
        transform: rotateX(-90deg) translateZ($wallSize / 2);
        &::before {
          transform: rotateX(180deg) rotateZ(-90deg) translateZ(-1px);
          animation: zeroFour 4000ms -2000ms linear infinite;
        }
      }
      &:nth-child(5) {
        transform: rotateY(90deg) translateZ($wallSize / 2);
        &::before {
          transform: rotateX(180deg) translateZ(-1px);
          animation: zeroFour 4000ms linear infinite;
        }
      }
      &:nth-child(6) {
        transform: rotateY(-90deg) translateZ($wallSize / 2);
        &::before {
          transform: rotateX(180deg) rotateZ(180deg) translateZ(-1px);
          animation: zeroFour 4000ms linear infinite;
        }
      }
    }
  }
}

@keyframes zeroFour {
  0% {
    content: '4';
  }
  100% {
    content: '0';
  }
}

@keyframes roll {
  0% {
    transform: rotateZ(0deg);
  }
  85% {
    transform: rotateZ(90deg);
  }
  87% {
    transform: rotateZ(88deg);
  }
  90% {
    transform: rotateZ(90deg);
  }
  100% {
    transform: rotateZ(90deg);
  }
}

@keyframes slide {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-$wallSize);
  }
}
```

## 3D 光影变换文字效果

利用 CSS 3D 实现光影变换文字效果。

### 关键点

- 给父元素 `div` 设置 `transform-style: preserve-3d`，给每个 `<h1>` 设定不同的 `translateZ()` 来达到文字的 3D 效果
- 辅助一些旋转，色彩变化给效果增色

HTML：

```
<div>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>
  <h1>Glowing 3D TEXT</h1>  
</div>
```

SCSS：

```scss
@import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300&display=swap');

html,
body {
    width: 100%;
    height: 100%;
    background: #000;
    overflow: hidden;
    text-align: center;
    font-family: 'Rajdhani', sans-serif;
}

div {
    animation: wobble 5s ease-in-out infinite;
    transform-origin: center center;
    transform-style: preserve-3d;
/*     perspective: 500px; */
}

@keyframes wobble {
    0%,
    100% {
        transform: rotate3d(1, 1, 0, 40deg);
    }
    25% {
        transform: rotate3d(-1, 1, 0, 40deg);
    }
    50% {
        transform: rotate3d(-1, -1, 0, 40deg);
    }
    75% {
        transform: rotate3d(1, -1, 0, 40deg);
    }
}

h1 {
    position: absolute;
    display: block;
    width: 100%;
    top: 120px;
    font-size: 100px;
    font-weight: bold;
    text-transform: uppercase;
    color: rgba(255, 100, 100, 1);
    text-shadow: 
        0 0 5px rgba(255, 0, 0, 1), 
        0 0 20px rgba(255, 0, 0, .8), 
        0 0 50px rgba(255, 0, 0, .6);
    animation: glow 10s ease-in-out infinite;
}

@keyframes glow {
    from {
        filter: hue-rotate(0);
    }
    to {
        filter: hue-rotate(360deg);
    }
}

h1:nth-child(2) {
    transform: translateZ(5px);
}
h1:nth-child(3) {
    transform: translateZ(10px);
}
h1:nth-child(4) {
    transform: translateZ(15px);
}
h1:nth-child(5) {
    transform: translateZ(20px);
}
h1:nth-child(6) {
    transform: translateZ(25px);
}
h1:nth-child(7) {
    transform: translateZ(30px);
}
h1:nth-child(8) {
    transform: translateZ(35px);
}
h1:nth-child(9) {
    transform: translateZ(40px);
}
h1:nth-child(10) {
    transform: translateZ(45px);
}
```

## 3D 无限延伸视角动画

3D 无限延伸视角动画。

### 关键点

这个实现起来非常有难度。

- 四面墙壁的无限延伸的感觉塑造
- 视角的变动
- 远处最深处的遮罩

非原创，原效果链接：[Perspective Origin Tunnel Animation](https://codepen.io/jkantner/pen/zXwyGr)

HTML：

```HTML
<main>
    <div class="t"></div>
    <div class="r"></div>
    <div class="b"></div>
    <div class="l"></div>
</main>
```

SCSS：

```scss
body {
    background: #575757;
    display: flex;
    height: 100vh;
    margin: 0;
    
}
main {
    /* Timing */
    --durM: 6s;
    --durD: 0.5s;
    /* Tunnel itself */
    --size: 20em;
    --depth: calc(var(--size) * 6);
    --bgPos: calc(var(--size) * 0.4);
    /* Camera movement */
    --endX1: 33%;
    --endX2: 67%;
    --endY1: 40%;
    --endY2: 60%;
    animation: po var(--durM) ease-in-out infinite;
    margin: auto;
    overflow: hidden;
    perspective: 5em;
    perspective-origin: 50% 50%;
    position: relative;
    width: var(--size);
    height: var(--size);
    transform: scale(6);
}
main:before, div {
    position: absolute;
}
main:before {
    animation: end var(--durM) ease-in-out infinite;
    background: currentColor;
    box-shadow: 0 0 1em 1em;
    color: #000;
    content: "";
    display: block;
    margin: -0.5em -0.5em;
    width: 1em;
    height: 1em;
    top: 50%;
    left: 50%;
    z-index: 5;
}
div {
    background: conic-gradient(#000 25%,#fff 0 50%,#000 0 75%,#fff 0) 0 0 / var(--bgPos) var(--bgPos);
}
.t, .l {
    top: 0;
    left: 0;
    transform-origin: 0 0;
}
.r, .b {
    right: 0;
    bottom: 0;
    transform-origin: 100% 100%;
}
.t, .b {
    width: 100%;
    height: var(--depth);
}
.r, .l {
    filter: brightness(70%);
    width: var(--depth);
    height: 100%;
}
.t {
    animation: t var(--durD) linear infinite;
    background-position: 0 calc(var(--bgPos) / 2);
    filter: brightness(40%);
    transform: rotateX(-90deg);
}
.r {
    animation: r var(--durD) linear infinite;
    background-position: calc(var(--bgPos) / 2) 0;
    transform: rotateY(-90deg);
}
.b {
    animation: b var(--durD) linear infinite;
    transform: rotateX(90deg);
}
.l {
    animation: l var(--durD) linear infinite;
    transform: rotateY(90deg);
}
@keyframes po {
    from, to { perspective-origin: var(--endX1) var(--endY1) }
    25% { perspective-origin: var(--endX2) var(--endY1) }
    50% { perspective-origin: var(--endX2) var(--endY2) }
    75% { perspective-origin: var(--endX1) var(--endY2) }
}
@keyframes t {
    to { transform: rotateX(-90deg) translateY(calc(var(--bgPos) * -1)) }
}
@keyframes r {
    to { transform: rotateY(-90deg) translateX(var(--bgPos)) }
}
@keyframes b {
    to { transform: rotateX(90deg) translateY(var(--bgPos)) }
}
@keyframes l {
    to { transform: rotateY(90deg) translateX(calc(var(--bgPos) * -1)) }
}
@keyframes end {
    from, to {
        top: var(--endY1);
        left: var(--endX1);
    }
    25% {
        top: var(--endY1);
        left: var(--endX2);
    }
    50% {
        top: var(--endY2);
        left: var(--endX2);
    }
    75% {
        top: var(--endY2);
        left: var(--endX1);
    }
}
```

## 3D 线条动画

3D 线条动画。

### 关键点

- 借助 SASS，其实是 100 个元素，借助 animation-delay 实现的一条线

HTML：

```pug
// pug模板
div.container
    - for(var i=0; i<100; i++)
        div.circle
```

SCSS：

```scss
$n: 100;

@function randomNum($max, $min: 0, $u: 1) {
    @return ($min + random($max)) * $u;
}

@function randomColor() {
    @return rgba(randomNum(255), randomNum(255), randomNum(255), randomNum(100)/100);
}

html,
body {
    width: 100%;
    height: 100%;
    background: #000;
    overflow: hidden;
}

.container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 1vmin;
    height: 1vmin;
    transform-style: preserve-3d;
    perspective: 1000;
    animation: screenMove 16s infinite alternate;
    // mix-blend-mode: lighten;
}

@for $i from 1 through $n { 
    .circle:nth-child(#{$i}) {
        position: absolute;
        top: 0;
        left: 0;
        width: 1vmax;
        height: 1vmax;
        border-radius: 50%;
        animation: anim-#{$i} 10s infinite 0.01s * $i alternate ease-in-out;
        background: hsl($i * 2, 95, 60);
        // mix-blend-mode: lighten;
    }
    
    @keyframes anim-#{$i}{
        100% {
          filter: hue-rotate(360deg);
          transform: 
            rotate(28 * 360deg) 
              translate3d(50vmin, 50vmin, -#{$i * 20}px)
            scale(6);
        }
    }
}

@keyframes screenMove {
    100% {
        transform: translate3d(-50%, -50%, 0) rotateY(45deg);
    }
}
```

## 3D 绳动画

非常好的学习 CSS 3D 的动画 DEMO。

HTML：

```HTML
<input type="checkbox" id="toggle" checked />
<section id="sect">
    <label for="toggle" class="toggle">change view</label>
    <ul>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
        <li>swing</li>
    </ul>
</section>
```

SCSS：

```scss
// vars

$random_color: rgba(rd(255),rd(255),rd(255),.33);

$c: ( // colors
    t: rgba(0,0,0,0),
    s: #000,
    w: #fff,
    gr: desaturate(rgb(rd(255),rd(255),rd(255)), 100%),
    r: rgb(rd(255),rd(150),rd(150)),
    g: rgb(rd(150),rd(255),rd(150)),
    b: rgb(rd(150),rd(150),rd(255)),
    bg: $random_color,
    cp: ( // color palette
        1: #283739,
        2: #2C5D63,
        3: #A9C52F,
        4: #F7EEBB
    ),
);

// settings
$f: unquote("'Podkova', serif");
$fb: unquote("'Trebuchet MS', Helvetica, sans-serif");
$fz: 16px;
// uncomment for responsive font-size
$fz: unquote('calc(1.1vw + 1.1vh - .6vmin)');
@media screen and (max-width: 600px) {
    body > * {
        font-size: 1.5em;
    }
}

$time: 4s;

// --------- defaults ---------
* {
    &:focus {
        outline: 0;
    }
    
    &, &:before, &:after {
        box-sizing: border-box;
    }
}
// @include placeholder(){
//         font-family: $f;
// }
// --------------------
html {
    background-color: clr(s);
    
    body {
        font-family: $f;
        font-size: $fz;
        color: clr(w);
        background-color: clr(bg);
    }
    
    &, body {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
    }
}
#toggle {
    display: none;
}

.toggle {
    position: fixed;
    z-index: 10;
    left: 1em;
    top: 1em;
    display: inline-block;
    padding: .4em .5em .5em;
    cursor: pointer;
    text-indent: 1.7em;
    color: clr(cp, 3);
    border-radius: .25em;
    transition: all $time/5;
    background-color: clr(cp, 1);
    
    &:before {
        content: '';
        position: absolute;
        z-index: 20;
        left: .5em;
        top: .4em;
        width: 1em;
        height: 1em;
        display: inline-block;
        border: 2px solid clr(cp, 2);
        vertical-align: middle;
        border-radius: 3px;
    }
    
    &:after {
        content: '';
        position: absolute;
        width: 0;
        height: 0;
        z-index: 21;
        display: inline-block;
        border: 2px solid clr(cp,4);
        border-width: 0 4px 4px 0;
        left: .75em;
        top: .75em;
        opacity: 0;
        transition: all $time/5;
        transform: rotate(45deg);

        #toggle:checked + #sect & {
            width: .5em;
            top: .25em;
            height: 1em;
            opacity: 1;
        }
    }
    
    #toggle:checked + #sect & {
        color: clr(cp, 4);
    }
}

#sect    {
    width: 100vw;
    height: 100vh;
    padding: 1em;
    text-align: center;
    vertical-align: middle;
    display: block;
    position: relative;
    perspective: 600px;
    
    ul {
        display: block;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        transition: all $time/3;
        transform-style: preserve-3d;
        transform: translateZ(-70vmax)  translateX(-50vw) rotateY(0deg);
        position: absolute;
        
        #toggle:checked + & {
            transform: translateZ(-50em)  translateX(0vw) rotateY(90deg);

        }
    }
    
    li {
        display: inline-block;
        position: absolute;
        font-size: 3em;
        margin-left: -5em;
        transition: all $time/5;
        // filter: blur(0px);
        opacity: 1;
        color: clr(cp, 4);
        transform-origin: center -123vmax;
        animation: pendulum ease-in-out infinite alternate $time;
        
        &:before {
            content: '';
            position: absolute;
            bottom: 100%;
            width: 1px;
            box-shadow: 0 0 0 .01em clr(cp, 3);
            height: 25em;
            left: 50%;
            background-color: clr(cp, 3);
        }
        
        @for $i from 0 to 24 {
            &:nth-of-type(#{$i}) {
                left: 2.5em * $i;
                animation-delay: -#{$i/10}s;

        #toggle:checked + & {
                // filter: blur(#{floor($i/3)}px);
                opacity: 1.2 - ($i/15);
                }
            }
        }
    }
}

@keyframes pendulum {
    from {
        transform: translateY(70vh) rotateX(-45deg);
    }
    to {
        transform: translateY(70vh) rotateX(45deg);
    }
}



// ease():
// default, in-cubic, out-cubic, in-out-cubic, in-circ, out-circ, in-out-circ, in-expo, out-expo, in-out-expo, in-quad, out-quad, in-out-quad, in-quart, out-quart, in-out-quart, in-quint, out-quint, in-out-quint, in-sine, out-sine, in-out-sine, in-back, out-back, in-out-back, liquid", bounce, in-out-bounce, perpetuum, impetus, full-circle, gravity, overshot, downhill, pendulum, wtf, swing
```

## 3D 螺旋数字动画

3D 螺旋数字动画。

### 关键点

- 借助 SASS，把每一列数字渐进旋转一定角度即可
- 当然，细心的你应该发现，每个数字一直都是面向正面的

HTML：

```pug
// pug模板
.container
    - for(var i=0; i<36; i++)
        .line
            - for(var j=0; j<12; j++)
                .number
```

SCSS：

```scss
$lineNumber: 36;
$column: 12;
$aniTime: 10s;

@function randomNum($max, $min: 0) {
    @return ($min + random($max));
}


html,
body {
    background-color: #000;
    overflow: hidden;
}

.container {
    width: 80vw;
    position: relative;
    margin: 10vh auto;
    transform-style: preserve-3d;
    perspective: 1000px;
    display: flex;
    justify-content: space-between;
    // mix-blend-mode: luminosity;
}

.line {
    width: 20px;
    height: 80vh;
    flex: 0 1 auto;
    display: flex;
    flex-wrap: wrap;
    flex-direction: column;
    justify-content: space-between;
    transform-style: preserve-3d;
    perspective: 1000px;
    
    .number {
        position: relative;
        font-size: 16px;
        height: calc(80vh / 18);
        border-radius: 50%;
        transform-style: preserve-3d;
        perspective: 1000px;
        box-shadow: 0 0 5px 5px rgba(255, 248, 78, .1),
            inset 0 0 5px 5px rgba(255, 248, 78, .1);
        line-height: calc(80vh / 18);
        
        &::before {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            text-align: center;   
            color: #57ff5e;
            text-shadow: 0 0 40px #57ff5e;
        }
    }
}

@for $i from 0 to $lineNumber {
    .line:nth-child(#{$i + 1}) {
        transform: rotateX(#{$i * 10}deg);
        
        
        @for $j from 0 to $column {
            .number:nth-child(#{$j + 1}) {
                // 卡就去掉这一行
                animation: reRotate $aniTime linear infinite;
                
                &::before {
                    transform: rotateX(#{$i * -10}deg);
                    content: '#{randomNum(9)}';
                }
            }
        }
    }
}

.container {
    transform: rotateX(0);
    animation: conRotate $aniTime linear infinite;
}

@keyframes conRotate {
    to {
        transform: rotateX(360deg);
    }
}

@keyframes reRotate {
    to {
        transform: rotateX(-360deg);
    }
}
```

## 借助 translate3d\perspective 实现 3D 视差效果

借助 translate3d\perspective 实现 3D 视差效果。

视差滚动（Parallax Scrolling）是指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 作为网页设计的热点趋势，越来越多的网站应用了这项技术。

### 关键点

- 我们给容器设置上 transform-style: preserve-3d 和 perspective: xpx，那么处于这个容器的子元素就将位于3D空间中，
- 再给子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z轴方向距离屏幕（我们的眼睛）的距离也就不一样
- 滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果。

详细分析请看：[滚动视差？CSS 不在话下](https://www.cnblogs.com/coco1s/p/9453938.html)

HTML：

```html
<div class="card">
  <div class="card-content">
    <h1>Just hover around</h1>
    <p>translateZ 3D</p>
    <p class="related">3D视差</p>
  </div>
</div>
```

SCSS：

```scss
body{
  background: #edf2f4;
  perspective: 1000px;
  transform-style: preserve-3d;
  display: flex;
  height: 100vh;
  font-family: "Playfair Display",georgia,serif;
}
.card{
  pointer-events: none;
  transform: translateZ(0);
  padding: 30px;
  background: white;
  border-radius: 5px;
  width: 400px;
  height: 200px;
  margin: auto;
  transform-style: preserve-3d;
  backface-visibility: hidden;
  display: flex;
  box-shadow: 0 0 5px rgba(0,0,0,.1);
  position: relative;
  animation: move 10s infinite alternate;
  
  &:after{
    content:" ";
    position: absolute;
    width: 100%;
    height: 10px;
    border-radius: 50%;
    left:0;
    bottom:-50px;
    box-shadow: 0 30px 20px rgba(0,0,0,.3);
    
  }
  
  .card-content{
    margin: auto;
    text-align:center;
    transform-style: preserve-3d;
    line-height: 40px;
  }
  
  h1{
    transform: translateZ(100px);
  }
  p{
    transform: translateZ(50px);
    display: block;
    
    &.related{
      transform: translateZ(80px);
      font-style: italic;
    }
  }
  a{
    color:#69c6b8;
    pointer-events: auto;
  }
}

@keyframes move {
    0% {
        transform: rotateY(20deg) rotateZ(10deg);
    }
    100% {
        transform: rotateY(-60deg) rotateZ(-10deg);
    }
}
```

## 借助 translate3d\perspective 实现 3D 视差效果2

借助 translate3d\perspective 实现 3D 视差效果2。

视差滚动（Parallax Scrolling）是指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 作为网页设计的热点趋势，越来越多的网站应用了这项技术。

### 关键点

- 我们给容器设置上 transform-style: preserve-3d 和 perspective: xpx，那么处于这个容器的子元素就将位于3D空间中，
- 再给子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z轴方向距离屏幕（我们的眼睛）的距离也就不一样
- 滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果。

详细分析请看：[滚动视差？CSS 不在话下](https://www.cnblogs.com/coco1s/p/9453938.html)

HTML：

```pug
// pug模板
div.g-container
    - for(var i=0; i<10; i++)
        div.g-section CSS Parallax
```

SCSS：

```scss
$length: 10;

@function randomNum($max, $min: 0, $u: 1) {
    @return ($min + random($max)) * $u;
}

body {
    background: #000;
    font-family: "lato", lucida grande,lucida sans unicode,lucida,helvetica,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif;
}

.g-container {
    width: 100vw;
    height: 100vh;
    overflow-x: hidden;
    overflow: scroll;
    transform-style: preserve-3d;
    // perspective: 1px;
    // mix-blend-mode: lighten;
    filter: blur(5px) contrast(5px);
    animation: perspectiveChange 10s infinite ease-in alternate;
}

.g-section {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    text-align: center;
    line-height: 100vh;
    padding: 30vh 0;
    font-size: 15vh;
}

@for $i from 1 through $length {
    .g-section:nth-child(#{$i}) {
        transform: translate3d(-200px, 0, -#{$i}px) scale(#{$i * 0.1 + 1 });
        $hue : $i * 35deg;
        color : hsla($hue, 100%, 60%, .8);
        // text-shadow: 0px 0px 1px hsla($hue, 100%, 60%, .9);
        z-index: #{$i};
    }
}

@keyframes perspectiveChange {
    0% {
        perspective: 12;
    }
    100% {
        perspective: 120;
    }
}
```

## 使用 translateZ 实现滚动视差

使用 `translateZ` 实现滚动视差。

视差滚动（Parallax Scrolling）是指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 作为网页设计的热点趋势，越来越多的网站应用了这项技术。

### 关键点

- 我们给容器设置上 transform-style: preserve-3d 和 perspective: xpx，那么处于这个容器的子元素就将位于3D空间中，
- 再给子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z轴方向距离屏幕（我们的眼睛）的距离也就不一样
- 滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果。

详细分析请看：[滚动视差？CSS 不在话下](https://www.cnblogs.com/coco1s/p/9453938.html)

HTML：

```html
<div class="g-container">
    <div class="section-one">translateZ(-1)</div>
    <div class="section-two">translateZ(-2)</div>
    <div class="section-three">translateZ(-3)</div>
</div>
```

SCSS：

```scss
html {
    height: 100%;
    overflow: hidden;
}

body {
    margin: 0;
    padding: 0;
    perspective: 2px;
    transform-style: preserve-3d;
    transform-origin: center center;
    height: 100%;
    overflow-y: scroll;
    overflow-x: hidden;
}

.g-container {
    position: relative;
    height: 150%;
    
    & > div {
        font-size: 5vw;  
        position: absolute;
        top: 20%;
    }
    
    .section-one {
        left: 0%;
        background: rgba(10, 10, 10, .2);
        transform: translateZ(-1px);
    }
    
    .section-two {
        left: 40%;
        background: rgba(30, 130, 30, .2);
        transform: translateZ(-2px);
    }
    
    .section-three {
        left: 90%;
        background: rgba(200, 100, 130, .2);
        transform: translateZ(-3px);
    }
}
```

## 借助transition-delay实现按钮border动画效果

借助 `transition-delay` 实现按钮 border hover 时的动画效果。

### 关键点

- 给容器每一边的 border 合理设置 `transition-delay`，可以延缓动画的发生，再连贯的拼凑在一起实现一些效果

HTML：

```html
<div class="both">Both</div>
<div class="rectangle">Rectangle</div>
<div class="circle">Circle</div>
```

SCSS：

```scss
body {
    background: #000;
}

div {
    position: relative;
    width: 200px;
    height: 64px;
    line-height: 64px;
    box-shadow: inset 0 0 0 3px #fff;
    margin: 50px auto;
    text-align: center;
    color: #fff;
    font-size: 32px;
    cursor: pointer;
    transition: color 1s;
}

div::before,
div::after {
    content: "";
    position: absolute;
    width: 0;
    height: 0;
    top: 0;
    left: 0;
    box-sizing: border-box;
    // transition: width .5s, height .5s;
    // transition-delay: .5s, 0s;
    border: 3px solid transparent;
}

.both:hover {
    color: #00e2ff;
    
    &::before {
        transition: width .5s, height .5s, border-bottom-color 0s;
        transition-delay: .5s, 0s, .5s;
        width: 200px;
        height: 64px;
        border-left: 3px solid #00e2ff;
        border-bottom: 3px solid #00e2ff;
    }
    
    &::after {
        transition: width .5s, height .5s, border-right-color .5s;
        transition-delay: 0s, .5s, .5s;
        width: 200px;
        height: 64px;
        border-top: 3px solid #00e2ff;
        border-right: 3px solid #00e2ff;
    }
}

.rectangle {
    &::after {
        top: unset;
        left: unset;
        right: 0;
        bottom: 0;
    }
    
    &:hover {
        color: #00e2ff;
        
        &::before {
            transition: width .25s, height .25s, border-bottom-color 0s;
            transition-delay: .25s, 0s, .25s;
            width: 200px;
            height: 64px;
            border-left: 3px solid #00e2ff;
            border-bottom: 3px solid #00e2ff;
        }

        &::after {
            transition: width .25s, height .25s, border-top-color .25s;
            transition-delay: 0.75s, 0.5s, 0.75s;
            width: 200px;
            height: 64px;
            border-top: 3px solid #00e2ff;
            border-right: 3px solid #00e2ff;
        }
    }   
}

.circle {
    width: 120px;
    height: 120px;
    line-height: 120px;
    border-radius: 50%;
    
    &::before,
    &::after{
        border-radius: 50%; 
    }
    
    &:hover {
        color: #00e2ff;
        
        &::before {
            width: 120px;
            height: 120px;
            border-color: #00e2ff;
            transition: border-top-color .25s linear,
                        border-right-color .25s linear,
                        border-bottom-color .25s linear,
                        border-left-color .25s linear;
            transition-delay: 0s, .25s, .5s, .75s;
        }
        
        &::after {
            width: 120px;
            height: 120px;
            border-top: 3px solid #00e2ff;
            transform: rotate(270deg);
            transition: transform .75s linear;
            transition-delay: 0s;
        }
    }
}
```

## CSS实现曲线运动

CSS实现曲线运动。

HTML：

```html
<div class="g-container">
    <div class="g-ball"></div>
</div>
```

SCSS：

```scss
.g-container {
    position: relative;
    width: 10vmin;
    height: 70vmin;
    margin: 20vmin auto;
    // background: rgba(0, 0, 0, .1);
    transform-origin: center 0;
    animation: rotate 1.5s cubic-bezier(.5, 0, .5, 1) infinite alternate, opacity 3s linear infinite alternate;
}

.g-ball {
    position: absolute;
    width: 10vmin;
    height: 10vmin;
    border-radius: 50%;
    background: radial-gradient(circle, #fff, #000);
    top: 60vmin;
    left: 0;
    animation: move 1.5s cubic-bezier(.5, 0, .5, 1) infinite alternate;
}

@keyframes opacity {
    from, 50% {
      border: 1px dashed rgba(255, 255, 255, 0);
    }
    to {
      border: 1px dashed rgba(0, 0, 0, .2);
    }
}

@keyframes rotate {
    100% {
        transform: rotate(90deg) translate(-3vmin, 0);
    }
}
```

## 利用 animation-delay 实现文字渐现效果

利用 animation-delay 实现文字渐现效果

### 关键点

1. hover 状态下和非 hover 状态下的 `transition-duration` 是不一样的，是因为取消 hover 过程中，动画消失过程的时间通常是要求更短的；
2. 借助了 SASS 的循环 `@for $i from 1 to 21 {}` 递增给每个 `span` 和它的伪元素添加了递增的 `transition-delay`；

### 线性渐变

HTML：

```HTML
<div class="button">Button</div>
<div class="g-wrap"></div>
<p><span data-text="Lorem">Lorem</span> <span data-text="ipsum">ipsum</span> <span data-text="dolor">dolor</span> <span data-text="sit">sit</span> <span data-text="amet">amet</span> <span data-text="consectetur">consectetur</span> <span data-text="adipisicing">adipisicing</span> <span data-text="elit.">elit.</span> <span data-text="Mollitia">Mollitia</span> <span data-text="nostrum">nostrum</span> <span data-text="placeat">placeat</span> <span data-text="consequatur">consequatur</span> <span data-text="deserunt">deserunt</span> <span data-text="velit">velit</span> <span data-text="ducimus">ducimus</span> <span data-text="possimus">possimus</span> <span data-text="commodi">commodi</span> <span data-text="temporibus">temporibus</span> <span data-text="debitis">debitis</span> <span data-text="quam.">quam.</span></p>
```

CSS：

```CSS
html,
body {
    width: 100%;
    height: 100%;
    display: flex;
    overflow: hidden;
}

.button {
    // position: fixed;
    top: 0;
    left: 0;
    width: 120px;
    height: 64px;
    line-height: 64px;
    text-align: center;
    border: 1px solid #eee;
    cursor: pointer;
    transition: .3s all;
    z-index: 1;

    &:hover {
        background: #eee;
    }
}

.button:hover ~ .g-wrap {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    transition: .3s background linear;
    background: rgba(0, 0, 0, .5);
    // z-index: -1;
}

p {
    position: relative;
    margin: 50px auto;
    width: 500px;
    height: 250px;
    font-size: 22px;
    line-height: 1.5;
    overflow: hidden;
    z-index: 2;
}

p span {
    position: relative;
    display: inline-block;
    opacity: 0;
    transform: translateY(15px) translateZ(0);
    transition-property: transform, opacity;
    transition-duration: .3s, .2s;
    transition-timing-function: cubic-bezier(.23,1,.32,1), linear;

}

.button:hover ~ p span {
    opacity: 1;
    color: #ddd;
    transform: translateY(0) translateZ(0);
    transition-property: transform, opacity;
    transition-duration: 1s, .2s;
    transition-timing-function: cubic-bezier(.23,1,.32,1), linear;

}

p span:after,
p span:before {
    position: absolute;
    content: attr(data-text);
    top: 0;
    left: 0;
    z-index: 1;
    transform: translateZ(0);
    will-change: opacity;
}

// p span:before {
//     color: #fff;
//     transition: opacity .6s .2s;
// }

// .button:hover ~ p span:before {
//     opacity: 0;
//     transition: opacity .6s .3s;
// }

p span:after {
    color: #e62541;
    transition-property: opacity;
    transition-duration: .1s;
    transition-timing-function: cubic-bezier(.23,1,.32,1);
}

.button:hover ~ p span:after {
    opacity: 0;
    transition-property: opacity;
    transition-duration: .4s;
    transition-timing-function: cubic-bezier(.23,1,.32,1);
}

@for $i from 1 to 21 {
    p span:nth-child(#{$i}) {
        transition-delay: #{$i * 0.04}s;
        
        &::after {
            transition-delay: #{$i * 0.04 + 0.2}s;
        }
    }
}
```

## 利用动画延迟实现波浪动画

利用动画延迟实现的波浪效果。

### 关键点

给每个子元素设定一个高度变化的动画，同时按顺序给每个元素设定一个不同时间的负延迟即可，就可以得到一个简单的波浪效果。

关于本效果的详情，你可以查看这篇文章：[一种巧妙的使用 CSS 制作波浪效果的思路](https://github.com/chokcoco/iCSS/issues/112)

HTML（使用了 Pug 模板引擎）：

```Pug
div.g-container
 -for(var i=0; i<24; i++)
    div.g-item
```

SCSS：

```scss
html,
body {
    width: 100%;
    height: 100%;
    display: flex;
    background: #fff;
}

$count: 24;
$speed: 1s;

:root {
    --angle: 15deg;
}

.g-container {
    position: relative;
    width: 200px;
    height: 200px;
    display: flex;
    align-items: flex-end;
    border-radius: 50%;
    border: 2px solid #000;
    overflow: hidden;
    flex-shrink: 0;
    margin: auto;
}

.rect {
    border-radius: 0;
}

.g-item {
    --f: #{$speed / -24};
    --h: 50px;
    flex-grow: 1;
    background-color: #000;
    animation: heightChange $speed infinite ease-in-out alternate;
}

.g-container .g-item {
    animation: heightChange $speed infinite ease-in-out alternate,
        skewChange $speed infinite ease-in-out alternate;
}

@for $i from 0 to $count {
    .g-container {
        .g-item:nth-child(#{$i + 1}) {
            animation-delay: calc(var(--f) * #{$i}),
                calc(var(--f) * #{$i} - #{$speed / 2});
        }
    }
}

@keyframes heightChange {
    from {
        height: var(--h);
    }
    to {
        height: calc(var(--h) + 30px);
    }
}

@keyframes skewChange {
    from {
        transform: scale(1.2) translate3d(0, 10px, 0) skewY(calc(var(--angle) * 1));
    }
    to {
        transform: scale(1.2) translate3d(0, 10px, 0) skewY(calc(var(--angle) * -1));
    }
}
```

## scale 配合 transfrom-origin 精准控制动画方向

scale 配合 transfrom-origin 精准控制动画方向。

其中具体的一些细节，的可以看看我的这篇文章：

[妙用 scale 与 transfrom-origin，精准控制动画方向](https://github.com/chokcoco/iCSS/issues/63)

HTML：

```HTML
<div>Hover Me</div>
```

SCSS：

```scss
div {
    position: absolute;
    width: 200px;
    height: 60px;
    line-height: 60px;
    font-size: 32px;
    cursor: pointer;
    color: #333;
    text-align: center;
    transition: color .5s;
    margin: 20px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

div::before {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 200px;
    transform: scaleX(0);
    height: 2px;
    background: deeppink;
    z-index: -1;
    transition: transform .5s;
    transform-origin: 100% 0;
}

div:hover::before {
    transform: scaleX(1);
    transform-origin: 0 0;
}
```

当然，其实这只是其中一种方案。

不使用 `transform-orign` + `scale` 也是可以实现的，直接使用定位的方案如下：

HTML：

```HTML
<div>Hover Me</div>
```

SCSS：

```scss
div {
    position: relative;
    width: 200px;
    height: 60px;
    margin: auto;
    line-height: 60px;
    font-size: 32px;
    cursor: pointer;
    color: #333;
    text-align: center;
    transition: color .5s;
}

div::before {
    content: "";
    position: absolute;
    right: 0;
    bottom: 0;
    width: 0;
    height: 2px;
    background: deeppink;
    transition: all .5s;
}

div:hover::before {
    left: 0;
    width: 200px;
}
```

## CSS 巧妙控制动画行进

CSS 巧妙控制动画行进。

其中具体的一些细节，的可以看看我的这篇文章：

[巧妙使用 CSS 控制动画行进](https://github.com/chokcoco/iCSS/issues/63)

HTML：

```pug
// pug模板语言
div.g-container
    div.g-btn
        -for(var i=0; i<60; i++)
            div.g-ball   
```

SCSS：

```scss
.g-container {
    width: 100%;
    height: 100%;
    overflow: hidden;
    filter: contrast(10);
    background: #000;
}

.g-btn {
    position: relative;
    width: 200px;
    height: 200px;
    margin: 130px auto;
    cursor: pointer;
    filter: blur(2px) contrast(10);
    
    &::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #dc8165;
        border-radius: 48% 45% 48% 46%;
        animation: rotate 3s infinite linear;
        z-index: 0;
    }
}

.g-ball {
    position: absolute;
    top: 50px;
    transform: translate(0, 0);
    background: #fa8763;
    border-radius: 50%;
    z-index: -1;
}

@for $i from 0 to $count {
    .g-ball:nth-child(#{$i}) {
        $width: #{random(60)}px;
        
        width: $width;
        height: $width;
        left: calc(#{(random(100))}px + 30px);
        animation: movetop .6s linear #{random(2000)/1000}s infinite;
        animation-play-state: running;
    }
    
    .g-btn:hover .g-ball:nth-child(#{$i}) {
        animation-play-state: paused;
    }
}

@keyframes movetop {
    0% {
        transform: translate(0, 0);
    }
    100% {
        transform: translate(0, -180px);
        opacity: .4;
    }
}

@keyframes rotate {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}
```

## 正负旋转相消动画

正负旋转相消动画。

### 关键点

利用了两个容器相向旋转，其中具体的一些细节，的可以看看我的这篇文章：

[你所不知道的 CSS 动画技巧与细节](https://www.cnblogs.com/coco1s/p/7443263.html)

HTML：

```html
<div class="reverseRotate">
    <div class="rotate">
        <div class="content">正负旋转相消3D动画</div>
    </div>
</div>
```

SCSS：

```scss
div {
    transform-style: preserve-3d;
    perspective: 500px;
}

.reverseRotate {
    margin: 20vh auto;
}

.rotate,
.reverseRotate {
    width: 50vh;
    height: 50vh;
}

.content {
    width: 100%;
    height: 100%;
    line-height: 50vh;
    text-align: center;
    background-color: rgba(255, 100, 100, .8);
    font-size: 5vh;
    color: #fff;
    box-shadow: 0px 0px 8px 2px rgba(100, 100, 100, .6);
}

.rotate {
    animation: rotate 5s linear infinite; 
}

.reverseRotate {
    animation: reverseRotate 5s linear infinite; 
}

@keyframes rotate {
    0% {
        transform: rotateX(0deg) rotateZ(0deg);
    }
    50% {
        transform: rotateX(40deg) rotateZ(180deg);
    }
    100% {
        transform: rotateX(0deg) rotateZ(360deg);
    }
}

@keyframes reverseRotate {
    0% {
        transform: rotateZ(0deg);
    }
    100% {
        transform: rotateZ(-360deg);
    }
}
```

## clip-path 实现边框线条动画 2

clip-path 实现边框线条动画。

### clip-path

一个非常有意思的 CSS 属性。

`clip-path` CSS 属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部 SVG 的路径。

[MDN - clip-path](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path)

### [关键点](https://chokcoco.github.io/CSS-Inspiration/#/./clippath/clippath-border-line-radius?id=关键点)

因为使用了 clip-path 裁剪后的元素，只有元素的剪切区域才能被显示，所以我们可以通过动画 animation 将几个关键帧绘制出来即可。

HTML：

```HTML
<div>Hello</div>
```

SCSS：

```scss
div {
    position: relative;
    margin: auto;
    width: 120px;
    line-height: 64px;
    text-align: center;
    color: #fff;
    font-size: 20px;
    border: 2px solid gold;
    border-radius: 10px;
    background: gold;
    transition: all .3s;
    cursor: pointer;
    
    &:hover {
        filter: contrast(1.1);
    }
    
    &:active {
        filter: contrast(0.9);
    }
    
    &::before,
    &::after {
        content: "";
        position: absolute;
        top: -10px;
        left: -10px;
        right: -10px;
        bottom: -10px;
        border: 2px solid gold;
        transition: all .5s;
        animation: clippath 3s infinite linear;
        border-radius: 10px;
    }
    
    &::after {
        animation: clippath 3s infinite -1.5s linear;
    }
}

@keyframes clippath {
    0%,
    100% {
        clip-path: inset(0 0 98% 0);
    }
    
    25% {
        clip-path: inset(0 98% 0 0);
    }
    50% {
        clip-path: inset(98% 0 0 0);
    }
    75% {
        clip-path: inset(0 0 0 98%);
    }
}

.bg::before {
    background: rgba(255, 215, 0, .5);
}
```

## clip-path 实现边框线条动画

clip-path 实现边框线条动画。

### clip-path

一个非常有意思的 CSS 属性。

`clip-path` CSS 属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部 SVG 的路径。

[MDN - clip-path](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path)

### 关键点

因为使用了 clip-path 裁剪后的元素，只有元素的剪切区域才能被显示，所以我们可以通过动画 animation 将几个关键帧绘制出来即可。

HTML：

```HTML
<div>Hello</div>
<div class="bg">示意图</div>
```

SCSS：

```scss
div {
    position: relative;
    margin: auto;
    width: 160px;
    line-height: 160px;
    text-align: center;
    font-size: 24px;
    
    &::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 2px solid gold;
        transition: all .5s;
        animation: clippath 3s infinite linear;
    }
}

@keyframes clippath {
    0%,
    100% {
        clip-path: inset(0 0 95% 0);
    }
    
    25% {
        clip-path: inset(0 95% 0 0);
    }
    50% {
        clip-path: inset(95% 0 0 0);
    }
    75% {
        clip-path: inset(0 0 0 95%);
    }
}

.bg::before {
    background: rgba(255, 215, 0, .5);
}
```

## clip-path 实现图片的故障艺术风格动画

clip-path 实现图片的故障艺术风格动画。

### clip-path

一个非常有意思的 CSS 属性。

`clip-path` CSS 属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部 SVG 的路径。

[MDN - clip-path](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path)

### 关键点

- 使用元素的伪元素复制两份图片副本，再使用 clip-path 对图片进行裁剪并且添加位移、变形、滤镜等等。
- 动画部分代码太多了，有一半使用了 SASS 的循环函数随机生成

HTML：

```HTML
<div></div>
```

SCSS：

```scss
$img: "xxx";

@function randomNum($max, $min: 0, $u: 1) {
    @return ($min + random($max)) * $u;
}

div {
    position: relative;
    width: 658px;
    height: 370px;
    margin: auto;
    background: url($img) no-repeat;
    animation: main-img-hide 20s infinite step-end;
}

div::before,
div::after {
    position: absolute;
    width: 658px;
    height: 370px;
    top: 0;
    left: 0;
    background: inherit;
}

div::after {
    content: "";
    animation: glitch-one 20s infinite step-end;
}

div::before {
    content: "";
    animation: glitch-two 20s infinite 1s step-end;
}

@keyframes glitch-one {
    @for $i from 20 to 30 {
        #{$i / 2}% {
            left: #{randomNum(200, -100)}px;
            clip-path: inset(#{randomNum(150, 30)}px 0 #{randomNum(150, 30)}px);
        }
    }

    15.5% {
        clip-path: inset(10px 0 320px);
        left: -20px;
    }
    16% {
        clip-path: inset(10px 0 320px);
        left: -10px;
        opacity: 0;
    }
    45% {
        opacity: 0.5;
        left: -20px;
        filter: hue-rotate(90deg) saturate(1.3);
    }
    45.5% {
        left: 0px;
        filter: invert(1);
    }

    46% {
        clip-path: inset(150px 0 160px);
        left: 15%;
    }
    46.5% {
        clip-path: inset(20px 0 200px);
        left: -10%;
        transform: scale(1.1);
    }
    47% {
        clip-path: inset(240px 0 20px);
        left: -11%;
        transform: scale(1.2);
    }
    47.5% {
        clip-path: inset(20 0 20px);
        left: 13%;
        transform: scale(1.3);
        filter: invert(0);
    }
    48% {
        clip-path: inset(120 0 120px);
        left: 15%;
        transform: scale(1.1);
    }
    48.5% {
        clip-path: inset(260px 0 10px);
        left: -11%;
        transform: scale(1.2);
        filter: none;
    }
    49% {
        clip-path: inset(5px 0 350px);
        left: 11%;
        transform: scale(1.3);
    }
    49.5% {
        clip-path: inset(105px 0 210px);
        left: 0%;
        transform: scale(1.1);
    }
    50% {
        clip-path: inset(175px 0 160px);
        left: -11%;
    }
    50.5% {
        clip-path: inset(95px 0 230px);
        left: -14%;
        transform: scale(1.2);
    }
    51% {
        clip-path: inset(235px 0 12px);
        left: -14%;
    }
    51.5% {
        clip-path: inset(350px 0 7px);
        left: -14%;
    }
    52% {
        clip-path: inset(320px 0 27px);
        left: -12%;
        transform: scale(1.1);
    }
    52.5% {
        clip-path: inset(190px 0 127px);
        left: -11%;
        transform: scale(1.3);
        filter: hue-rotate(90deg) saturate(1.3);
    }
    54% {
        clip-path: inset(20px 0 20px);
        left: 12%;
        transform: scale(1.1);
        filter: none;
    }
    54% {
        background-image: none;
    }
}

@keyframes glitch-two {
    @for $i from 40 to 50 {
        #{$i / 2}% {
            left: #{randomNum(200, -100)}px;
            clip-path: inset(#{randomNum(180)}px 0 #{randomNum(180)}px);
        }
    }

    25.5% {
        clip-path: inset(10px 0 320px);
        left: -20px;
    }
    26% {
        clip-path: inset(10px 0 320px);
        left: -10px;
        opacity: 0;
    }
    45% {
        opacity: 0.3;
        left: -20px;
        filter: hue-rotate(45deg) saturate(1.1);
    }
    45.5% {
        left: 0px;
        filter: invert(1.2);
    }

    46% {
        clip-path: inset(50px 0 260px);
        left: -12%;
    }
    46.5% {
        clip-path: inset(120px 0 100px);
        left: 8%;
        transform: scale(1.2);
    }
    47% {
        clip-path: inset(40px 0 300px);
        left: 8%;
        transform: scale(1.3);
    }
    47.5% {
        clip-path: inset(220 0 70px);
        left: -9%;
        transform: scale(1.1);
        filter: invert(1.1);
    }
    48% {
        clip-path: inset(240px 0 120px);
        left: 11%;
        transform: scale(1.2);
    }
    48.5% {
        clip-path: inset(0px 0 310px);
        left: -12%;
        transform: scale(1.2);
        filter: none;
    }
    49% {
        clip-path: inset(255px 0 50px);
        left: 11%;
        transform: scale(1.3);
    }
    49.5% {
        clip-path: inset(10px 0 240px);
        left: 6%;
        transform: scale(1.1);
    }
    50% {
        clip-path: inset(275px 0 90px);
        left: -12%;
    }
    50.5% {
        clip-path: inset(195px 0 90px);
        left: 14%;
        transform: scale(1.4);
    }
    51% {
        clip-path: inset(35px 0 282px);
        left: -14%;
    }
    51.5% {
        clip-path: inset(350px 0 7px);
        left: 14%;
    }
    52% {
        clip-path: inset(20px 0 270px);
        left: -12%;
        transform: scale(1.1);
    }
    52.5% {
        clip-path: inset(90px 0 227px);
        left: -11%;
        transform: scale(1.3);
        filter: hue-rotate(150deg) saturate(1.3);
    }
    54% {
        clip-path: inset(220px 0 100px);
        left: 12%;
        transform: scale(1.1);
        filter: none;
    }
    54% {
        background-image: none;
    }
}

@keyframes main-img-hide {
    5% {
        filter: invert(1);
    }
    5.2% {
        filter: none;
    }
    10% {
        opacity: 0.5;
        filter: grayscale(1);
    }
    11% {
        filter: none;
        opacity: 1;
    }
    45% {
        opacity: 0.5;
        filter: grayscale(1);
    }
    46% {
        filter: none;
        opacity: 1;
    }
    53.5% {
        opacity: 0.5;
        filter: grayscale(1);
    }
    54% {
        filter: none;
        opacity: 1;
    }
    54.5% {
        opacity: 0.5;
        filter: hue-rotate(30deg);
    }
    55% {
        filter: none;
    }
    55.5% {
        background-image: none;
        filter: none;
        opacity: 1;
    }
    56% {
        background-image: url($img);
        opacity: 0.5;
    }
    56.5% {
        background-image: none;
    }
    57% {
        background-image: url($img);
        opacity: 0.8;
    }
    57.5% {
        opacity: 0.3;
    }
    58% {
        background-image: none;
    }
}
```

## clip-path 实现文字断裂效果

clip-path 实现文字断裂效果。

### clip-path

一个非常有意思的 CSS 属性。

`clip-path` CSS 属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部 SVG 的路径。

[MDN - clip-path](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path)

### 关键点

核心思想是：使用元素的伪元素复制两份文本，再使用 clip-path 将元素本身、元素的两个伪元素分为3部分，分别对这3部分进行控制。

因为使用了 clip-path 裁剪后的元素，只有元素的剪切区域才能被显示，所以我们可以分别控制 3 个部分进行动画。

HTML：

```HTML
<h1 data-text="Text Crack">
    <span>Text Crack</span>
</h1>
```

SCSS：

```scss
body, html
{
    display: flex;
    height: 100%;
    width: 100%;
    background-color: #000;
    overflow: hidden;
    font-family: sans-serif;
}

h1 {
    position: relative;
    margin: auto;
    font-size: calc(20px + 5vw);
    font-weight: bold;
    color: #fff;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    text-shadow: 0 0 10px blue;
    user-select: none;
    white-space: nowrap;
    filter: blur(0.007em);
    animation: shake 2.5s linear forwards;
}

h1 span {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-50%, -50%);
    clip-path: polygon(10% 0%, 44% 0%, 70% 100%, 55% 100%);
}

h1::before,
h1::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
}

h1::before {
    animation: crack1 2.5s linear forwards;
    clip-path: polygon(0% 0%, 10% 0%, 55% 100%, 0% 100%);
}

h1::after {
    animation: crack2 2.5s linear forwards;
    clip-path: polygon(44% 0%, 100% 0%, 100% 100%, 70% 100%);
}

@keyframes shake {
    5%,
    15%,
    25%,
    35%,
    55%,
    65%,
    75%,
    95% {
        filter: blur(0.018em);
        transform: translateY(0.018em) rotate(0deg);
    }

    10%,
    30%,
    40%,
    50%,
    70%,
    80%,
    90% {
        filter: blur(0.01em);
        transform: translateY(-0.018em) rotate(0deg);
    }

    20%,
    60% {
        filter: blur(0.03em);
        transform: translate(-0.018em, 0.018em) rotate(0deg);
    }

    45%,
    85% {
        filter: blur(0.03em);
        transform: translate(0.018em, -0.018em) rotate(0deg);
    }

    100% {
        filter: blur(0.007em);
        transform: translate(0) rotate(-0.5deg);
    }
}

@keyframes crack1 {
    0%,
    95% {
        transform: translate(-50%, -50%);
    }

    100% {
        transform: translate(-51%, -48%);
    }
}

@keyframes crack2 {
    0%,
    95% {
        transform: translate(-50%, -50%);
    }

    100% {
        transform: translate(-49%, -53%);
    }
}
```

## 利用 resize 实现图片切换预览功能

利用 resize 实现图片切换预览功能 。

### 关键点

- CSS `resize` 属性允许你控制一个元素的可调整大小性
- 配合 `resize` 实现子元素的动态宽度

HTML：

```
<div class='picA'>
    <div class='picB'>
        <div readonly class='resizeElement'></div>
    </div>
</div>
```

SCSS：

```scss
html {
    background: #ddd;
    height: 100%;
    width: 100%;
}
.picA {
    background-image: url(https://z3.ax1x.com/2021/08/17/fhJdpQ.png);
    background-size: cover;
    width: 650px;
    height: 340px;
    border: 5px solid #f0e5ab;
    border-radius: 3px;
    box-shadow: 0 0 1px #999, -2px 2px 3px rgba(0, 0, 0, 0.2);
    padding: 0;
    margin: 1rem auto;
    position: relative;
    overflow: hidden;
}
.picB {
    background-image: url(https://z3.ax1x.com/2021/08/17/fhJUfg.png);
    background-size: cover;
    height: 340px;
    position: absolute;
    top: 0;
    left: 0;
    min-width: 0;
    max-width: 650px;
    box-sizing: border-box;
}
.picB:before {
    content: "↔";
    position: absolute;
    background: rgba(0, 0, 0, 0.5);
    font-size: 16px;
    color: white;
    top: 0;
    right: 0;
    height: 100%;
    line-height: 340px;
}
.resizeElement {
    resize: horizontal;
    overflow: scroll;
    opacity: 0;
    position: relative;
    top: 50%;
    left: 0px;
    height: 15px;
    max-width: 650px;
    min-width: 15px;
    width: 0;
    cursor: move;
    transform: scaleY(35);
    transform-origin: center center;
    animation: delta 5s normal ease-in-out 1s;
}
@keyframes delta {
    30% {
        width: 0;
    }
    60% {
        width: 350px;
    }
    100% {
        width: 0;
    }
}
```

## 暗黑字符雨动画

纯 CSS 实现的暗黑字符雨动画。

### 关键点

- 文字的竖排
- 使用 CSS 实现随机字符串的选取
- 使用 CSS 实现打字效果
- 增加光影与透明度变化

详细信息，可以看看我的这篇文章：

[【Web动画】科技感十足的暗黑字符雨动画](https://juejin.cn/post/6991657194282450951)

HTML（这里使用了 Pug 模板引擎）：

```pug
// pug模板
.g-container
    -for(var i=0; i<50; i++)
        p
```

SCSS：

```scss
@import url('https://fonts.googleapis.com/css2?family=Inconsolata:wght@200&display=swap');
$str: 'ぁぃぅぇぉかきくけこんさしすせそた◁▣▤▥▦▧♂♀♥☻►◄▧▨♦ちつってとゐなにぬねのはひふへほゑまみむめもゃゅょゎをァィゥヴェォカヵキクケヶコサシスセソタチツッテトヰンナニヌネノハヒフヘホヱマミムメモャュョヮヲㄅㄉㄓㄚㄞㄢㄦㄆㄊㄍㄐㄔㄗㄧㄛㄟㄣㄇㄋㄎㄑㄕㄘㄨㄜㄠㄤㄈㄏㄒㄖㄙㄩㄝㄡㄥabcdefghigklmnopqrstuvwxyz123456789%@#$<>^&*_+';
$length: str-length($str);
$n: 50;
$animationTime: 4;
$perColumnNums: 25;

@function randomChar() {
    $r: random($length);
    @return str-slice($str, $r, $r);
}

@function randomChars($number) {
    $value: '';

    @if $number > 0 {
        @for $i from 1 through $number {
            $value: $value + randomChar();
        }
    }
    @return $value;
}

body, p {
    margin: 0;
    padding: 0;
}

body, html {
    width: 100%;
    height: 100%;
    background: #000;
    display: flex;
    overflow: hidden;
}

.g-container {
    width: 100vw;
    display: flex;
    justify-content: space-between;
    flex-wrap: nowrap;
    flex-direction: row;
    font-family: 'Inconsolata', monospace, sans-serif;
}

p {
    position: relative;
    width: 5vh;
    height: 100vh;
    text-align: center;
    font-size: 5vh;
    word-break: break-all;
    white-space: pre-wrap;
    
    &::before,
    &::after {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 100%;
        overflow: hidden;
    }
}

@for $i from 0 through $n {
    $content: randomChars($perColumnNums);
    $contentNext: randomChars($perColumnNums);
    $delay: random($n);
    $randomAnimationTine: #{$animationTime + random(20) / 10 - 1}s;
    
    p:nth-child(#{$i})::before {
        content: $content;
        color: rgb(179, 255, 199);
        text-shadow: 0 0 1px #fff, 0 0 2px #fff, 0 0 5px currentColor, 0 0 10px currentColor;
        animation: typing-#{$i} $randomAnimationTine steps(20, end) #{$delay * 0.1s * -1} infinite;
        z-index: 1;
    }

    p:nth-child(#{$i})::after {
        $alpha: random(40) / 100 + 0.6;
        content: '';
        background: linear-gradient(rgba(0, 0, 0, $alpha), rgba(0, 0, 0, $alpha), rgba(0, 0, 0, $alpha), transparent 75%, transparent);
        background-size: 100% 220%;
        background-repeat: no-repeat;
        animation: mask $randomAnimationTine infinite #{($delay - 2) * 0.1s * -1} linear;
        z-index: 2;
    }

    @keyframes typing-#{$i} {
        0% {
            height: 0;
        }
        25% {
            height: 100%;
        }
        100% {
            height: 100%;
            content: $contentNext;
        }
    }
}

@keyframes mask{
    0% {
        background-position: 0 220%;
    } 
    30% {
        background-position: 0 0%;
    }
    100% {
        background-position: 0 0%;
    }
}
```

## chrome Tab 分栏实现

chrome Tab 分栏实现

### 关键点

有很多小细节

- 每个 tab active 状态下的边框实现，需要借助两个伪元素
- 正常状态、hover状态、active状态下的层级关系

可以自己动手尝试下。

HTML：

```HTML
<ul class="container">
    <li>
        <img src="https://jestjs.io/img/favicon/favicon.ico" alt="">
        <span>The Jest Object</span>
        <div class="close">﹢</div>
        <div class="line"></div>
    </li>
    <li class="">
        <img src="https://static.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico" alt="">
        <span>ChromeTab分栏实现</span>
        <div class="close">﹢</div>
        <div class="line"></div>
    </li>
    <li class="active">
        <img src="https://github.com/fluidicon.png" alt="">
        <span>chokcoco（Coco）</span>
        <div class="close">﹢</div>
        <div class="line"></div>
    </li>
</ul>
```

SCSS：

```scss
.container {
    background: #ddd;
    height: 40px;
    margin: 20px auto;
    padding: 8px 8px 0;
    box-sizing: border-box;
    display: flex;
    justify-content: flex-start;
    overflow: hidden;
}

li {
    position: relative;
    font-size: 12px;
    border-radius: 10px 10px 0 0;
    flex-basis: 240px;
    display: flex;
    align-items: center;
    z-index: 1;
    cursor: default;
    transition: .3s all;
    
    img {
        width: 16px;
        height: 16px;
        margin-left: 10px;
        margin-right: 10px; 
    }
    
    .line {
        display: none;
        left: -1px;
        top: 6px;
        position: absolute;
        width: 1px; 
        height: 20px;
        background: #909090;
    }
    
    .close {
        right: 8px;
        top: 8px;
        position: absolute;
        font-size: 18px;
        transform: rotate(45deg);
        border-radius: 50%;
        cursor: pointer;
        font-weight: bold;
        
        &:hover {
            background: #d0d0d0;
        }
    }
}

li.active {
    background: #fff;
    z-index: 2;
    
    &::before,
    &::after {
        border-top: 5px solid #fff;
    }
}

li::before,
li::after {
    position: absolute;
    content: "";
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 5px solid transparent;
    transition: .3s all;
    //border-top: 5px solid #fff;
}

li::before {
    bottom: -5px;
    left: -15px;
    transform: rotate(135deg)
}

li::after {
    bottom: -5px;
    right: -15px;
    transform: rotate(205deg)
}

li + li:not(.active) .line {
    display: block
}

li:hover:not(.active) {
    background: #ededed;
    
    .line {
        display: none!important;
    }
    
    &::before,
    &::after {
       border-top: 5px solid #ededed; 
    }
}

li:hover + li {
    .line {
        display: none!important;
    }
}
```

## 等角螺线

等角螺线。

等角螺线，一个很有意思的几何图形。

等角螺线的臂的距离以几何级数递增。 等角螺线是自我相似的；这即是说，等角螺线经放大后可与原图完全相同。 等角螺线的渐屈线和垂足曲线都是等角螺线。 从原点到等角螺线的任意点上的长度有限，但由那点出发沿等角螺线走到原点却需绕原点转无限次。

### 关键点

1. 借助了三角函数，而 CSS 本身是没有三角函数的，所以需要使用 SCSS 实现三角函数方法（Sin、Cos）
2. SCSS 实现三角函数又借助了泰勒公式，具体可以看我的这篇文章：[在 CSS 中使用三角函数绘制曲线图形及展示动画](https://github.com/chokcoco/iCSS/issues/72)

Pug模板（HTML模板引擎）：

```pug
- for(var i=0; i<32; i++)
    .box
```

SCSS：

```scss
// scss 实现 sin、cos、tan
$pi: 3.14159265359;
$_precision: 10;

@function pow($base, $exp) {
    $value: $base;
    @if $exp > 1 {
        @for $i from 2 through $exp {
            $value: $value * $base;
        }
    }
    @if $exp < 1 {
        @for $i from 0 through -$exp {
            $value: $value / $base;
        }
    }
    @return $value;
}

@function fact($num) {
    $fact: 1;
    @if $num > 0 {
        @for $i from 1 through $num {
            $fact: $fact * $i;
        }
    }
    @return $fact;
}

@function _to_unitless_rad($angle) {
    @if unit($angle) == "deg" {
        $angle: $angle / 180deg * $pi;
    }
    @if unit($angle) == "rad" {
        $angle: $angle / 1rad;
    }
    @return $angle;
}

@function sin($angle) {
    $a: _to_unitless_rad($angle);
    $sin: $a;
    @for $n from 1 through $_precision {
        $sin: $sin + (pow(-1, $n) / fact(2 * $n + 1)) * pow($a, (2 * $n + 1));
    }
    @return $sin;
}

@function cos($angle) {
    $a: _to_unitless_rad($angle);
    $cos: 1;
    @for $n from 1 through $_precision {
        $cos: $cos + (pow(-1, $n) / fact(2 * $n)) * pow($a, 2 * $n);
    }
    @return $cos;
}

@function tan($angle) {
    @return sin($angle) / cos($angle);
}

$squares: 32;
$angle: $pi / ($squares - 1);
$ratio: 1 / (sin($angle) + cos($angle));
$size: 100;

div {
    position: absolute;
    left: 50%;
    top: 50%;
    border: 2px black solid;
    @for $i from 0 through $squares {
        &:nth-child(#{$i}) {
            $s: pow($ratio, $i) * $size;
            width: #{$s}vmin;
            height: #{$s}vmin;
            transform: translate(-50%, -50%) rotate(#{$angle}rad);
        }
        $angle: $i * $pi / ($squares - 1);
    }
}
```

## 华为充电动画

华为充电动画

本 Demo 详细信息可阅读：

[巧用 CSS 实现酷炫的充电动画](https://github.com/chokcoco/iCSS/issues/75)

HTML：

```HTML
<div class="g-container">
    <div class="g-number">98.7%</div>
    <div class="g-contrast">
        <div class="g-circle"></div>
        <ul class="g-bubbles">
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
        </ul>
    </div>
</div>
```

SCSS：

```scss
html,
body {
    width: 100%;
    height: 100%;
    display: flex;
    background: #000;
    overflow: hidden;
}
.g-number {
    position: absolute;
    width: 300px;
    top: 27%;
    text-align: center;
    font-size: 32px;
    z-index: 10;
    color: #fff;
}

.g-container {
    position: relative;
    width: 300px;
    height: 400px;
    margin: auto;
}

.g-contrast {
    filter: contrast(10) hue-rotate(0);
    width: 300px;
    height: 400px;
    background-color: #000;
    overflow: hidden;
    animation: hueRotate 10s infinite linear;
}

.g-circle {
    position: relative;
    width: 300px;
    height: 300px;
    box-sizing: border-box;
    filter: blur(8px);
    
    &::after {
        content: "";
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%) rotate(0);
        width: 200px;
        height: 200px;
        background-color: #00ff6f;
        border-radius: 42% 38% 62% 49% / 45%;
        animation: rotate 10s infinite linear;
    }
    
    &::before {
        content: "";
        position: absolute;
        width: 176px;
        height: 176px;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background-color: #000;
        z-index: 10;
    }
}

.g-bubbles {
    position: absolute;
    left: 50%;
    bottom: 0;
    width: 100px;
    height: 40px;
    transform: translate(-50%, 0);
    border-radius: 100px 100px 0 0;
    background-color: #00ff6f;
    filter: blur(5px);
}

li {
    position: absolute;
    border-radius: 50%;
    background: #00ff6f;
}

@for $i from 0 through 15 { 
    li:nth-child(#{$i}) {
        $width: 15 + random(15) + px;
        left: 15 + random(70) + px;
        top: 50%;
        transform: translate(-50%, -50%);
        width: $width;
        height: $width;
        animation: moveToTop #{random(6) + 3}s ease-in-out -#{random(5000)/1000}s infinite;
    }
}

@keyframes rotate {
    50% {
        border-radius: 45% / 42% 38% 58% 49%;
    }
    100% {
        transform: translate(-50%, -50%) rotate(720deg);
    }
}

@keyframes moveToTop {
    90% {
        opacity: 1;
    }
    100% {
        opacity: .1;
        transform: translate(-50%, -180px);
    }
}

@keyframes hueRotate {
    100% {
        filter: contrast(15) hue-rotate(360deg);
    }
}
```

## 夜晚居室图

夜晚居室图（不知道叫什么好）

### 关键点

1. 使用了渐变完成了墙面窗户和地板上窗户的倒影
2. 使用了 transform 变换完成了视觉上的效果
3. 使用了 shadow 实现了门缝透光效果

HTML：

```HTML
<div class="container">
    <div class="window">
        <div class="moon"></div>
    </div>
    <div class="floor"></div>
    <div class="door"></div>
</div>
```

SCSS：

```scss
$dark: #0d0d2d;
$outside: #999;

body,
html {
    width: 100%;
    height: 100%;
    background: #0d0d2d;
}

.container {
    width: 400px;
    height: 400px;
    margin: 0 auto;
    perspective: 180px;
}

.window {
    position: absolute;
    top: 0;
    left: 0;
    width: 400px;
    height: 200px;
    transform: translate3d(250px, 110px, -190px) rotateY(110deg);
    
    &::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: $outside;
        z-index: 1;
    }
    
    &::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            linear-gradient(0deg, transparent 12px, $dark 12px, $dark 15px),
            linear-gradient(90deg, $dark 20px, transparent),
            linear-gradient(90deg, $dark 20px, transparent),
            linear-gradient(90deg, $dark 5px, transparent),
            linear-gradient(90deg, $dark 5px, transparent);
        background-size: 100% 15px, 20px 100%, 20px 100%, 5px 100%, 5px 100%;
        background-repeat: repeat, no-repeat, no-repeat, no-repeat, no-repeat;
        background-position: 0 10px, 100px 0, 280px 0, 50px 0, 200px 0;
        z-index: 3;
    }
    
    .moon {
        position: absolute;
        width: 60px;
        height: 100px;
        top: 13px;
        left: 3px;
        background: #e6e6e6;
        z-index: 2;
        border-radius: 50%;
        box-shadow: inset 16px 5px 8px #e6e6e6;
        -webkit-transform: scale(0.6);
        transform: scale(0.3);
    }
}

.floor {
    position: absolute;
    top: 0;
    left: 0;
    width: 400px;
    height: 200px;
    transform: translate3d(7px, 270px, -115px) rotateZ(-90deg) rotateY(100deg);
    
    &::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: $outside;
        z-index: 1;
    }
    
    &::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            linear-gradient(0deg, transparent 12px, $dark 12px, $dark 15px),
            linear-gradient(90deg, $dark 20px, transparent),
            linear-gradient(90deg, $dark 20px, transparent),
            linear-gradient(90deg, $dark 5px, transparent),
            linear-gradient(90deg, $dark 5px, transparent);
        background-size: 100% 15px, 20px 100%, 20px 100%, 5px 100%, 5px 100%;
        background-repeat: repeat, no-repeat, no-repeat, no-repeat, no-repeat;
        background-position: 0 10px, 100px 0, 280px 0, 50px 0, 200px 0;
        z-index: 2;
    }
}

.door {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate3d(-50%, -50%, -290px);
    width: 50px;
    height: 100px;
    border-radius: 100px 100px 0 0 ;
    background: linear-gradient(45deg, transparent 65%, $outside);
    box-shadow: inset -5px 5px 4px $outside;
}
```

## 纯CSS实现360°饼图

纯CSS实现360°饼图

### 关键点

- 核心在于超过 180° 时，使用一个半圆图辅助

HTML：

```HTML
<div class="container">
    <div class="left">
        <div class="left-pie"></div>
    </div>
    <div class="right">
        <div class="right-pie"></div>
    </div>
</div>
```

SCSS：

```scss
body {
    background: #000;
}

.container {
    position: relative;
    width: 200px;
    height: 200px;
    margin: 50px auto;
}

.left {
    position: absolute;
    left: 100px;
    top: 0;
    width: 100px;
    height: 200px;
    overflow: hidden;
    
    .left-pie {
        position: relative;
        left: -100px;
        width: 200px;
        height: 200px;
        background: linear-gradient(90deg, transparent 50%, yellowgreen 50%);
        border-radius: 50%;
        transform-origin: 50% 50%;
        transform: rotate(-180deg);
        animation: rotate 4s infinite linear;
    }
}

.right {
    position: absolute;
    left: 0;
    top: 0;
    width: 100px;
    height: 200px;
    overflow: hidden;
    
    .right-pie {
        position: relative;
        left: 0;
        width: 200px;
        height: 200px;
        background: linear-gradient(90deg, yellowgreen 0%, yellowgreen 50%, transparent 50%);
        border-radius: 50%;
        transform-origin: 50% 50%;
        transform: rotate(-180deg);
        animation: rotate 4s infinite 2s linear;
    }
}

@keyframes rotate {
    50% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(0deg);
    }
}
```

## PURE CSS 实现鼠标跟随2

PURE CSS 实现鼠标跟随2。

### 关键点

- 障眼法，通过将屏幕铺满 div 进行控制鼠标跟随
- 通过 hover 以及 transtion 改变元素的透明度

详细信息，可以看看我的这篇文章：

[不可思议的纯 CSS 实现鼠标跟随](https://github.com/chokcoco/iCSS/issues/46)

HTML：

```pug
// pug模板
.bg hover me
.container
    - for(var i=0; i<500; i++)
        .box
```

SCSS：

```scss
$count: 500;

@function randomNum($max, $min: 0, $u: 1) {
    @return ($min + random($max)) * $u;
}

.bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    line-height: 100vh;
    text-align: center;
    font-size: 15vw;
    -webkit-text-fill-color: transparent;
    -webkit-text-stroke: 1px rgba(118, 218, 255, .8);
    z-index: -1;
}

.container {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    cursor: pointer;
    z-index: 100;
    
    .box {
        position: relative;
        float: left;
        width: 30px;
        height: 30px;
        margin: 4px;
        // mix-blend-mode: multiply;    
        
        &::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;  
            transform: scale3d(0.1, 0.1, 1);
            background-color: transparent;
            transition: .5s transform ease-in,
                        .5s background ease-in;
        }
    }
    
    .box:hover {
        &::before {
            transform: scale3d(1.8, 1.8, 1.8);
            transition: 0s transform;
        }
    }
}

@for $i from 1 through $count {   
    .box:nth-child(#{$i}):hover {
        &::before {
            background-color: rgba(randomNum(255), randomNum(255), randomNum(255), .8);
        }
    }
}
```

## PURE CSS 实现鼠标跟随3

PURE CSS 实现鼠标跟随3。

### 关键点

- 障眼法，通过将屏幕铺满 div 进行控制鼠标跟随
- 配合了滤镜 `blur` 以及 `contrast`

详细信息，可以看看我的这篇文章：

[不可思议的纯 CSS 实现鼠标跟随](https://github.com/chokcoco/iCSS/issues/46)

HTML：

```pug
// pug模板
div.g-container
    -for(var i=0; i<100; i++)
        div.position
    .ball
        -for(var j=0; j<10; j++)
            .point
```

SCSS：

```scss
$count: 100;
$points: 10;

.g-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    // mix-blend-mode: screen;
}

.position {
    position: absolute;
    width: 10vw;
    height: 10vh;
    box-sizing: border-box;
    cursor: pointer;
    // border: 1px solid #eee;
}

@for $i from 0 through $count {
    $x: $i % 10;
    $y: ($i - $x) / 10;

    .position:nth-child(#{$i + 1}) {
        top: #{$y * 10}vh;
        left: #{$x * 10}vw;
    }

    .position:nth-child(#{$i + 1}):hover ~ .ball .point {
        top: #{$y * 10 + 5}vh;
        left: #{$x * 10 + 5}vw;
        // transform: translate(-50%, -50%) scale(random(2) + 0.2);
        //
    }
}

.ball {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;
    filter: blur(5px) contrast(10) hue-rotate(50deg);
    // background: #000;
    background: linear-gradient(45deg, #000, #333, #666, #999, #ccc, #fff);

    .point {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        mix-blend-mode: difference;
    }

    @for $j from 0 through $points {
        .point:nth-child(#{$j}) {
            width: 3vmax + 1vmax * $j;
            height: 3vmax + + 1vmax * $j;
            border: 0.9vmax solid #fff;
            border-radius: 50%;
            transition: 1s;
            transition-delay: 8ms * $j;
            transition-timing-function: cubic-bezier(0.27, 1.06, 0.82, 1.11);
        }
    }
}

@keyframes rotate {
    100% {
        transform: translate(-50%, -50%) rotate(90deg) scale(1.2);
    }
}
```

## PURE CSS 实现鼠标跟随

PURE CSS 实现鼠标跟随。

### 关键点

- 其实也是障眼法，通过将屏幕铺满 div 进行控制。

详细信息，可以看看我的这篇文章：

[不可思议的纯 CSS 实现鼠标跟随](https://github.com/chokcoco/iCSS/issues/46)

HTML：

```pug
// pug模板
div.g-container
    -for(var i=0; i<100; i++)
        div.position
    .ball
```

SCSS：

```scss
$count: 100;

.g-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

.position {
    position: absolute;
    width: 10vw;
    height: 10vh;
    box-sizing: border-box;
    cursor: pointer;
    // border: 1px solid #eee;
}

@for $i from 0 through $count { 
    
    $x: $i % 10;
    $y: ($i - $x) / 10;
    
    .position:nth-child(#{$i + 1}) {
        top: #{$y * 10}vh;
        left: #{$x * 10}vw;
    }
    
    .position:nth-child(#{$i + 1}):hover ~ .ball {
        top: #{$y * 10 + 5}vh;
        left: #{$x * 10 + 5}vw;
        // transform: translate(-50%, -50%) scale(random(2) + 0.2);
        // 
    }
}

.ball {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 10vmax;
    height: 10vmax;
    border-radius: 43%;
    border: 2px solid #333;
    transform: translate(-50%, -50%) rotate(0deg) scale(.8);
    transition: .1s ease-in;
    // transition-delay: .01s;
    animation: rotate 3s infinite ease-in-out alternate;
    z-index: -1;
}

@keyframes rotate {
    100% {
        transform: translate(-50%, -50%) rotate(90deg) scale(1.2);
    }
}
```

## 利用 box-reflect 实现光影按钮

[`-webkit-box-reflect`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-box-reflect) 是一个非常有意思的属性，它让 CSS 有能力像镜子一样，反射我们元素原本绘制的内容。

### 核心点

利用了 `-webkit-box-reflect` 实现按钮的倒影效果，非常的有科技感。

详细信息可以看我的这篇文章：

[巧用 -webkit-box-reflect 倒影实现各类动效](https://github.com/chokcoco/iCSS/issues/100)

HTML：

```HTML
<div class="btn">Neon</div>
<div class="btn btn1">Neon</div>
<div class="btn btn2">Neon</div>
<div class="btn btn3">Neon</div>
```

SCSS：

```scss
:root {
    --color: #0ebeff;
}

@keyframes rotate {
    100% {
        transform: translate(-50%, -50%) rotate(1turn);
    }
}

.btn {
    position: relative;
    z-index: 0;
    width: 160px;
    height: 80px;
    line-height: 80px;
    color: var(--color);
    font-size: 24px;
    border-radius: 10px;
    text-align: center;
    margin: auto;
    overflow: hidden;
    cursor: pointer;
    transition: .3s;
    -webkit-box-reflect: below 10px linear-gradient(transparent, rgba(0, 0, 0, .4));

    &:hover {
        color: #fff;
        box-shadow: 0 0 5px var(--color),
            0 0 25px var(--color);
        
        &::after,
        &::before {
            transition: .3s;
            background: var(--color);
        }
    }
    
    &::before {
        content: '';
        position: absolute;
        z-index: -2;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 150%;
        height: 300%;
        background-color: #000;
        background-repeat: no-repeat;
        background-size: 50% 50%;
        background-position: 0 0;
        background-image: conic-gradient(var(--color), var(--color));
        animation: rotate 2s linear infinite;
    }
    
    &::after {
        content: '';
        position: absolute;
        z-index: -1;
        left: 2px;
        top: 2px;
        width: calc(100% - 4px);
        height: calc(100% - 4px);
        background: #000;
        border-radius: 10px;
    }
}

.btn1 {
    filter: hue-rotate(180deg);
}

.btn2 {
    filter: hue-rotate(270deg);
}

.btn3 {
    filter: hue-rotate(90deg);
}
```

## 利用 box-reflect 实现 3D 照片墙倒影效果

[`-webkit-box-reflect`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-box-reflect) 是一个非常有意思的属性，它让 CSS 有能力像镜子一样，反射我们元素原本绘制的内容。

### 核心点

利用了 `-webkit-box-reflect` 实现 3D 照片墙的倒影效果，非常的有科技感。

详细信息可以看我的这篇文章：

[巧用 -webkit-box-reflect 倒影实现各类动效](https://github.com/chokcoco/iCSS/issues/100)

HTML：

```HTML
<div class="container">
    <!-- 舞台层 -->
    <div class="stage">
        <!-- 控制层 -->
        <div class="control">
            <!-- 图片层 -->
            <div class="imgWrap">
                <div class="img img1">
                    <img src="https://static.apdnews.com/image/20161228/1482898199741754.jpg">
                </div>
                <div class="img img2"><img src="https://i.pinimg.com/originals/e8/ba/25/e8ba252917952f23dfc9715e942e654e.jpg"></div>
                <div class="img img3"><img src="https://www.womenly.net/wp-content/uploads/2017/03/Tips-to-Maintain-the-Soft-Skin.jpg"></div>
                <div class="img img4"><img src="https://usa-grlk5lagedl.stackpathdns.com/production/usa/images/1607033935377530-bella-hadid-world-s-most-beautiful-woman.jpeg?w=868&h=660&crop=faces&auto=%5B%22format%22%2C%20%22compress%22%5D&cs=srgb&fit=crop"></div>
                <div class="img img5"><img src="https://c4.wallpaperflare.com/wallpaper/290/224/929/women-face-choker-portrait-wallpaper-preview.jpg"></div>
                <div class="img img6"><img src="https://webneel.com/wallpaper/sites/default/files/images/09-2018/beautiful-woman-wallpaper-annnevreva.jpg"></div>
                <div class="img img7"><img src="http://mywordsnthoughts.com/myworld/wp-content/uploads/2018/01/beautiful-neck.jpg"></div>
                <div class="img img8"><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTD8kEsEE3hJ64aU-_TKQJtvKDtTOGQfT3A4A&usqp=CAU"></div>
            </div>
        </div>
    </div>
</div>
```

SCSS：

```scss
$imgCount : 8;
html, body {
    background: #000;
}

.container{
    position:relative;
}

.stage{
    position:relative;
    width: 800px;
    height: 240px;
    margin: 20px auto;
    perspective:2000px;
    transform-style: preserve-3d;
    -webkit-box-reflect: below 10px linear-gradient(transparent, rgba(0, 0, 0, .5));
    
    .control{
        position:relative;
        width:100%;
        height:100%;
        transform-style: preserve-3d;
        transform: translateZ(-2000px) rotateY(50deg) rotateZ(0deg);
        animation:rotate 30s linear infinite;
        
        .imgWrap{
            position:absolute;
            width:400px;
            height:400px;
            top:50%;
            left:50%;
            transform:translate(-50%, -50%);
            transform-style: preserve-3d;
            
            .img{
                position:absolute;
                width:500px;
                height:400px;
                line-height:400px;
                text-align:center;
                font-size:120px;
                top:0;
                left:0;
                transform-style: preserve-3d;
                transform-origin: 50% 50% 0px;
            }
            
            img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            @for $i from 1 through $imgCount{
                .img#{$i}{
                    // transform: rotateY(35 + ($i * 45deg)) translateZ(482.84px) ;
                    transform: rotateY(35 + ($i * 45deg)) translateZ(650px) ;
                }
            }
        }
    }
}

@keyframes rotate{
    0%{
        transform: translateZ(-2000px) rotateY(0deg);
    }
    50%{
        transform: translateZ(-2000px) rotateY(-360deg);
    }
    100%{
        transform: translateZ(-2000px) rotateY(-720deg);
    }
}
```

## CSS文字分裂移动特效

CSS文字分裂移动特效。

### 关键点

- 使用多个容器，将文字进行了渐进分割
- 配合了滤镜 `blur` 以及 `contrast`

HTML：

```pug
// pug模板
div.g-container
    -for(var i=0; i<10; i++)
        .g-view 
            .g-text MAGICSS 
```

SCSS：

```scss
$count: 10;

html,
body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #000;
}

.g-container {
    position: relative;
    margin: 20vh auto;
    width: 33vw;
    height: 10vw;
    filter: blur(0.2vw) contrast(20);
}

.g-view {
    top: 0;
    left: 0;
    // transform: translate(-50%, -50%) rotate(0deg) scale(1);
    position: absolute;
    overflow: hidden;
    font-size: 6vw;
    height: 10vw;
    background: #000;
    mix-blend-mode: screen;
}

.g-text {
    top: 0;
    left: 0;
    position: absolute;
    width: 33vw;
    color: #fff;
    // text-align: center;
}

@for $i from 0 through $count {  
    .g-view:nth-child(#{$i}) {
        width: #{$i * 3}vw;
        animation: rotate 2s ease-in-out #{$i * 80}ms forwards;
        z-index: 10 - $i;
        
        $j: $i - 1;
        
        &::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: #{$j * 3}vw;
            height: 10vw;
            background: #000;
            z-index: 1;
        }
    }    
}

@keyframes rotate {
    0% {
        transform: translate(0) rotate(0deg) scaleX(1) skewX(0) skewY(0);
    }
    50% {
        transform: translate(40vw, 20vh) rotate(-180deg) scaleX(1.5) skewX(40deg) skewY(-20deg);
    }
    100% {
        transform: translate(0vw) rotate(-360deg) scaleX(1) skewX(0) skewY(0);
    }
}


@keyframes move {
    100% {
        transform: translate(0, 4vw);
    }
}
```

## CSS文字分裂特效

CSS文字分裂特效。

### 关键点

- 使用多个容器，将文字进行了渐进分割
- 配合了滤镜 `blur` 以及 `contrast`

HTML：

```pug
// pug模板
div.g-container
    -for(var i=0; i<11; i++)
        .g-view 
            .g-text MAGICCSS 
```

SCSS：

```scss
$count: 11;

html,
body {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

.g-container {
    position: relative;
    margin: 20vh auto;
    width: 33vw;
    height: 10vw;
    filter: blur(0.2vw) contrast(8);
}

.g-view {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(0deg) scale(1);
    position: absolute;
    overflow: hidden;
    font-size: 6vw;
    height: 10vw;
}

.g-text {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    position: absolute;
    width: 33vw;
    text-align: center;
}

@for $i from 0 through $count {  
    .g-view:nth-child(#{$i}) {
        width: #{$i * 3}vw;
        animation: rotate 1.5s ease-in #{$i * 140}ms;
        z-index: 10 - $i;
        
        &::before {
            $j: $i - 1;
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: #{$j * 3}vw;
            height: 10vw;
            background: #fff;
            z-index: 1;
        }
    }    
}

@keyframes rotate {
    0% {
        transform: translate(-50%, -50%) rotate(0deg) scaleX(1);
    }
    50% {
        transform: translate(-50%, -50%) rotate(180deg) scaleX(0.1);
    }
    100% {
        transform: translate(-50%, -50%) rotate(360deg) scaleX(1);
    }
}
```

## CSS文字故障效果

CSS文字故障效果。

### 关键点

- 利用了伪元素生成了文字的两个副本
- 视觉效果由位移、遮罩、混合模式完成
- 配色借鉴了抖音 LOGO 的风格

详细信息可以看我的这篇文章：

[CSS 故障艺术](https://github.com/chokcoco/iCSS/issues/78)

HTML：

```HTML
<div class="text-magic" data-word="CSSTextMagic">
    CSSTextMagic
    <div class="white"></div>
</div>
```

SCSS：

```scss
.text-magic {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(2.4);
    width: 300px;
    font-size: 36px;
    font-family: Raleway, Verdana, Arial;
    color: #fff;
}
.white {
    position: absolute;
    left: -10px;
    width: 100%;
    height: 3px;
    background: #000;
    z-index: 4;
    animation: whiteMove 3s ease-out infinite;
}

.text-magic::before {
    content: attr(data-word);
    position: absolute;
    top: 0;
    left: 0.5px;
    height: 0px;
    color: rgba(255, 255, 255, 0.9);
    overflow: hidden;
    z-index: 2;
    animation: redShadow 1s ease-in infinite;
    filter: contrast(200%);
    text-shadow: 1px 0 0 red;
}

.text-magic::after {
    content: attr(data-word);
    position: absolute;
    top: 0;
    left: -3px;
    height: 36px;
    color: rgba(255, 255, 255, 0.8);
    overflow: hidden;
    z-index: 3;
    background: rgba(0, 0, 0, 0.9);
    animation: redHeight 1.5s ease-out infinite;
    filter: contrast(200%);
    text-shadow: -1px 0 0 cyan;
    mix-blend-mode: darken;
}

@keyframes redShadow {
    20% {
        height: 32px;
    }
    60% {
        height: 6px;
    }
    100% {
        height: 42px;
    }
}

@keyframes redHeight {
    20% {
        height: 42px;
    }
    35% {
        height: 12px;
    }
    50% {
        height: 40px;
    }
    60% {
        height: 20px;
    }
    70% {
        height: 34px;
    }
    80% {
        height: 22px;
    }
    100% {
        height: 0px;
    }
}

@keyframes whiteMove {
    8% {
        top: 38px;
    }
    14% {
        top: 8px;
    }
    20% {
        top: 42px;
    }
    32% {
        top: 2px;
    }
    99% {
        top: 30px;
    }
}
```

## CSS-Doodle spotlight🎆

CSS-Doodle spotlight🎆

### CSS-doodle

[css-doodle](https://github.com/css-doodle/css-doodle) 是一个基于 Web-Component 的库。允许我们快速的创建基于 CSS Grid 布局的页面，以实现各种 CSS 效果（或许可以称之为 CSS 艺术）。

HTML：

```HTML
<!-- https://css-doodle.com -->

<css-doodle>
    :doodle { 
        @grid: 1x26 / 100vw 100vh; 
        background: #000;
    } 
    
    :container { 
        max-width: 70vw;
        margin: 0 auto;
    } 
    

    @even {
        position: relative;
        height: 70%;
        top: 10%;
        background: linear-gradient(to top, rgba(@r(50, 255), @r(255, 255), 255, 1), rgba(255, 255, 255, .1) 80%);
        transform: perspective(@r(7, 35)vmin) rotateX(-@r(15, 45)deg) skewX(@r(-60, 60)deg);
        transform-origin: center bottom;
        box-shadow: 0 0 2vmin .1vmin rgba(255, 255, 255, .7);
        opacity: 0;
        animation: fadeIn 7s infinite calc(@index() * 0.03s);
    }
    
    @keyframes fadeIn {
        1% {
            opacity: 1;
        }
        10% {
            opacity: 1;
            filter: hue-rotate(0);
        }
        50% {
            opacity: 1;
            transform: perspective(@r(10, 35)vmin) rotateX(-@r(15, 45)deg) skewX(0deg);
            filter: hue-rotate(360deg);
        }
        50.1% {
            opacity: 0;
        }
    }

</css-doodle>
```

SCSS：

```scss
html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}CSS-Doodle spotlight🎆
CSS-Doodle spotlight🎆

CSS-doodle
css-doodle 是一个基于 Web-Component 的库。允许我们快速的创建基于 CSS Grid 布局的页面，以实现各种 CSS 效果（或许可以称之为 CSS 艺术）。

HTML：

<!-- https://css-doodle.com -->

<css-doodle>
    :doodle { 
        @grid: 1x26 / 100vw 100vh; 
        background: #000;
    } 
    
    :container { 
        max-width: 70vw;
        margin: 0 auto;
    } 
    

    @even {
        position: relative;
        height: 70%;
        top: 10%;
        background: linear-gradient(to top, rgba(@r(50, 255), @r(255, 255), 255, 1), rgba(255, 255, 255, .1) 80%);
        transform: perspective(@r(7, 35)vmin) rotateX(-@r(15, 45)deg) skewX(@r(-60, 60)deg);
        transform-origin: center bottom;
        box-shadow: 0 0 2vmin .1vmin rgba(255, 255, 255, .7);
        opacity: 0;
        animation: fadeIn 7s infinite calc(@index() * 0.03s);
    }
    
    @keyframes fadeIn {
        1% {
            opacity: 1;
        }
        10% {
            opacity: 1;
            filter: hue-rotate(0);
        }
        50% {
            opacity: 1;
            transform: perspective(@r(10, 35)vmin) rotateX(-@r(15, 45)deg) skewX(0deg);
            filter: hue-rotate(360deg);
        }
        50.1% {
            opacity: 0;
        }
    }

</css-doodle>
SCSS：

html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

## 夏日城市夕阳图🌇

夏日城市夕阳图🌇

### CSS-doodle

[css-doodle](https://github.com/css-doodle/css-doodle) 是一个基于 Web-Component 的库。允许我们快速的创建基于 CSS Grid 布局的页面，以实现各种 CSS 效果（或许可以称之为 CSS 艺术）。

HTML：

```HTML
<!-- https://css-doodle.com -->

<css-doodle>
    :doodle { @grid: 1x35 / 100vw 100vh; } 
    :container { 
        background: #ffcabb; 
        background: linear-gradient(to top, #ffcabb 50%, #de93b6 100%); 
        background-repeat: no-repeat; 
    } 
    
    position: relative; 
    align-self: end;
    height: @rand(10%, 75%);
    background: linear-gradient(to
    top, #725392 0%, #b764ac 100%);
    margin-left: @rand(0.1, 1)vw;
    z-index: 1;
    transform: scaleX(@rand(.8, 1.9));
    
    ::before { 
        content: ""; 
        position: absolute; 
        bottom: 0; 
        left: @rand(-20, 12)px; 
        right: @rand(-20, 12)px; 
        top: @rand(15, 55)%; 
        background: linear-gradient(to
        top, #352864 0%, #4d4280 100%); 
        z-index: 3; 
    } 
    
    ::after { 
        content: "";
        position: absolute;
        width: .1vw;
        height: .12vw;
        top: @rand(15, 20)%;
        left: @rand(10, 20)%;
        z-index: 5;
        box-shadow: 
            @rand(0.1, 2.1)vw @rand(0, 10)vh .5px rgba(246, 212, 0, .7),
            @rand(0.1, 2.1)vw @rand(10, 15)vh .5px rgba(246, 212, 0, .6), 
            @rand(0.1, 2.1)vw @rand(15, 22)vh .5px rgba(246, 212, 0, .7), 
            @rand(0.1, 2.1)vw @rand(22, 30)vh .5px rgba(246, 212, 0, .6), 
            @rand(0.1, 2.1)vw @rand(30, 40)vh .5px rgba(246, 212, 0, .8);
    }

</css-doodle>
```

SCSS：

```scss
html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

body::after {
    content: "";
    position: absolute;
    top: 10vmin;
    right: 20vmin;
    background: #fff;
    width: 8vh;
    height: 8vh;
    border-radius: 50%;
    box-shadow: 0 0 20px 2px rgba(253, 220, 189, 0.9);
}
```

## 支付宝AR扫福动画

支付宝AR扫福动画。

### 关键点

使用了 `stroke-dasharray` 和 `stroke-dashoffset` 控制线条动画。

具体的可以看看我的这篇文章：

[【Web动画】SVG 线条动画入门](https://www.cnblogs.com/coco1s/p/6225973.html)

HTML：

```html
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300px" height="300px">
    <polygon class="g-polygon-wrap" points="150 0, 300 75, 300 225, 150 300, 0 225,  0 75, 150 0" />
    <polygon class="g-polygon-move" points="150 0, 300 75, 300 225, 150 300, 0 225,  0 75, 150 0" />
</svg>
```

SCSS：

```scss
html,
body {
    width: 100%;
    height: 100%;
    display: flex;
    background: #000;
}

svg {
    margin: auto;
    overflow: visible;
    transform: scalex(.9);
}

.g-polygon-wrap,
.g-polygon-move {
    fill: none; 
    stroke: #bf303c; 
    stroke-width: 2;
    stroke-linejoin: round;
    stroke-linecap: round;
}

.g-polygon-move {
    transform-origin: center center;
    transform: scale(1.05);
    stroke: linear-gradinet(180deg, red, transprent);
    stroke-width:1.5;
    stroke-dasharray: 280, 700;
    stroke-dashoffset: 8;
    animation: move 2.4s infinite linear;
}

@keyframes move {
    0% {
        stroke-dashoffset: 8;
    }
    100% {
        stroke-dashoffset: -972;
    }
}
```

## SVG 按钮 hover 线条动画

SVG 按钮 hover 线条动画。

### 关键点

使用了 `stroke-dasharray` 和 `stroke-dashoffset` 控制线条动画。

具体的可以看看我的这篇文章：

[【Web动画】SVG 线条动画入门](https://www.cnblogs.com/coco1s/p/6225973.html)

HTML：

```html
<a class="container">
  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
    <rect class="outline" height="100%" width="100%" />
    <div class="text">SVG Animations</div>
  </svg>
</a>

<a class="container2">
  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
    <rect class="outline" height="100%" width="100%" />
    <div class="text">SVG Animations</div>
  </svg>
</a>

<a class="container3">
  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
    <rect class="outline" height="100%" width="100%" />
    <div class="text">SVG Animations</div>
  </svg>
</a>

<a class="container4">
  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
    <rect class="outline" height="100%" width="100%" />
    <div class="text">SVG Animations</div>
  </svg>
</a>

<a class="container4-5">
  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
    <rect class="outline" height="100%" width="100%" />
    <div class="text">SVG Animations</div>
  </svg>
</a>

<a class="container5">
  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
    <rect class="outline" height="100%" width="100%" />
    <div class="text">SVG Animations</div>
  </svg>
</a>

<a class="container6">
  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg">
    <rect class="outline" height="100%" width="100%" />
    <div class="text">SVG Animations</div>
  </svg>
</a>
```

SCSS：

```scss
$default: #ffcc00;
$pink: deeppink;

html {
  background: #000;
  text-align: center;
  color: $default;
  *,
  *:before,
  *:after {
    @include transition(1s);
    @include box-sizing(border-box);
  }
}

[class^="container"] {
  display: block;
  position: relative;
  color: $default;
  text-decoration: none;
  @include size(250px, 50px);
  margin: 50px auto;
  overflow: hidden;
  .outline {
    @include coverer;
    stroke: $default;
    stroke-width: 2px;
    fill: transparent;
  }
  .text {
    @include relative(-40px);
    font-family: 'Helvetica';
    font-size: 1.5rem;
    line-height: 1;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  &:hover {
    .outline {
      stroke: $pink;
    }
    .text {
      color: $pink;
    }
  }
}

.container {
  .outline {
    stroke-dasharray: 25 25;
    stroke-dashoffset: -588;
  }
  &:hover {
    .outline {
      stroke-dasharray: 50 50;
      stroke-dashoffset: -275;
    }
  }
}

.container2 {
  .outline {
    stroke-dasharray: 50 250;
    stroke-dashoffset: -575;
  }
  &:hover {
    .outline {
      stroke-dasharray: 50 100;
      stroke-dashoffset: -75;
    }
  }
}

.container3 {
  .outline {
    stroke-dasharray: 70 230;
    stroke-dashoffset: 60;
  }
  &:hover {
    .outline {
      stroke-dashoffset: -350;
    }
  }
}

.container4 {
  .outline {
    stroke-dasharray: 50 600;
    stroke-dashoffset: -550;
    @include transition(0.5s);
  }
  &:hover {
    .outline {
      stroke-dashoffset: -250;
    }
  }
}

@include keyframes(woop) {
  0% {
    stroke-dasharray: 50 600;
    stroke-dashoffset: -550;
  }
  40%, 50% {
    stroke-dasharray: 50 600;
    stroke-dashoffset: -250;
  }
  100% {
    stroke-dasharray: 600 0;
    stroke-dashoffset: 25;
  }
}

.container4-5 {
  .outline {
    stroke-dasharray: 50 600;
    stroke-dashoffset: -550;
    @include transition(1s);
  }
  &:hover {
    .outline {
      stroke-dasharray: 600 0;
      stroke-dashoffset: 25;
      @include animation(woop 1s linear);
    }
  }
}

.container5 {
  .outline {
    stroke-dasharray: 100 500;
    stroke-dashoffset: 225;
    @include transition(0.5s);
  }
  &:hover {
    .outline {
      stroke-dasharray: 600 0;
      stroke-dashoffset: 475;
    }
  }
}

.container6 {
  .outline {
    stroke-dasharray: 50 550;
    stroke-dashoffset: 200;
    @include transition(0.5s);
  }
  &:hover {
    .outline {
      stroke-dasharray: 50 250;
      stroke-dashoffset: 500;
    }
  }
}

@include keyframes(bounceRight) {
  0% {
    @include translateX(-100%);
  }
  30% {
    @include translateX(-100%);
  }
  40%, 60%, 80%, 100% {
    @include translateX(0);
  }
  50% {
    @include translateX(-30%);
  }
  70% {
    @include translateX(-15%);
  }
  90% {
    @include translateX(-7.5%);
  }
}
```

## SVG 配合 drop-shadow 实现线条光影效果

SVG 配合 drop-shadow 实现线条光影效果。

详见：[CSS 奇技淫巧 | 妙用 drop-shadow 实现线条光影效果](https://github.com/chokcoco/iCSS/issues/142)

HTML：

```HTML
<div class="container">
    <svg xmlns="http://www.w3.org/2000/svg">
        <path d="M 400 160 A 2 2 90 0 0 260 160 A 2 2 90 0 0 120 160 C 120 230 260 270 260 350 C 260 270 400 230 400 160" class="line" />
    </svg>
    <svg xmlns="http://www.w3.org/2000/svg">
        <path d="M 400 160 A 2 2 90 0 0 260 160 A 2 2 90 0 0 120 160 C 120 230 260 270 260 350 C 260 270 400 230 400 160" class="line line2" />
    </svg>
</div>
```

CSS：

```CSS
html, body {
    width: 100%;
    height: 100%;
    display: flex;
    background: linear-gradient(#1a0f19, #16121c);
}

svg {
    position: absolute;
    width: 600px;
    height: 600px;
}

.container {
    position: relative;
    width: 400px;
    height: 400px;
    margin: auto;
}


.line {
    --colorA: #f24983;
    fill: none;
    stroke-width: 10;
    stroke-linejoin: round;
    stroke-linecap: round;
    stroke: #fff;
    stroke-dasharray: 328 600;
    animation: rotate 2s infinite linear;   
    filter:
        drop-shadow(0 0 2px var(--colorA))
        drop-shadow(0 0 5px var(--colorA))
        drop-shadow(0 0 10px var(--colorA))
        drop-shadow(0 0 15px var(--colorA))
        drop-shadow(0 0 25px var(--colorA));
}

.line2 {
    animation: rotate 2s infinite -1s linear;   
    --colorA: #37c1ff;
}


@keyframes rotate {
  0% {
    stroke-dashoffset: 0;
  }
  100% {
    stroke-dashoffset: 928;
  }
}
```

## 利用 SVG feTurbulence 滤镜及 filter: blur 实现鸿蒙 LOGO

利用 SVG feTurbulence 滤镜及 filter: blur 实现鸿蒙 LOGO

### 关键点

- filter 滤镜的应用
- SVG feTurbulence 滤镜 的应用

### 线性渐变

HTML：

```HTML
<div class="g-container">
    <div class="g-top"></div>
    <div class="g-bottom"></div>
    <p>Harmony <span>O</span>S</p>
</div>
<svg>
    <filter id="fractal" filterUnits="objectBoundingBox" x="0%" y="0%" width="100%" height="100%">
        <feTurbulence id="turbulence" type="fractalNoise" baseFrequency="0.02 0.02" numOctaves="5">
            <animate
                 attributeName="baseFrequency"
                 dur="20s" 
                 values="0.02 0.02;0.022 0.15;0.02 0.02"
                 repeatCount="indefinite" />
        </feTurbulence>
        <feDisplacementMap in="SourceGraphic" scale="15"></feDisplacementMap>
    </filter>
</svg>
```

CSS：

```CSS
p {
    font-size: 36px;
    color: #fff;
    text-align: center;
    margin-top: 12px;
    
    span {
        display: inline-block;
        position: relative;
        &::before {
            content: "";
            position: absolute;
            bottom: 0;
            width: 18px;
            left: 50%;
            transform: translate(-50%, 4px);
            border-bottom: 4px solid #2d60aa;
        }
    }
}

svg {
    position: absolute;
}

.g-top {
    position: relative;
    width: 220px;
    height: 110px;
    background: #000;
    overflow: hidden;
    
    &::before {
        content: "";
        position: absolute;
        border-radius: 50%;
        top: 10px;
        left: 10px;
        right: 10px;
        width: 200px;
        height: 200px;
        box-sizing: border-box;
        border: 25px solid #fff;
        box-shadow: 
            0 0 4px 1px rgba(255, 255, 255, .8),
            0 0 8px 2px rgba(255, 255, 255, .6);
    }
}
.g-bottom {
    position: relative;
    width: 220px;
    height: 120px;
    background: #000;
    overflow: hidden;
    filter: url(#fractal);
    
    &::before {
        content: "";
        position: absolute;
        border-radius: 50%;
        top: 0;
        left: 10px;
        right: 10px;
        width: 200px;
        height: 200px;
        box-sizing: border-box;
        border: 25px solid #fff;
        z-index: 10;
        box-shadow: 
            0 0 4px 1px rgba(255, 255, 255, .8),
            0 0 8px 2px rgba(255, 255, 255, .6);
        transform: translate(0, -100px);
        filter: blur(4px);
    }
}
```

## SVG feTurbulence 滤镜实现故障按钮点击效果

使用 SVG feTurbulence 滤镜实现故障按钮点击效果 。

### 关键点

SVG `<feTurbulence>` 滤镜能够实现半透明的烟熏或波状图像。 通常用于实现一些特殊的纹理。本效果通过 `<feTurbulence>` 作用于背景色并且配合动画效果实现 故障按钮点击效果。

关于本效果的详细描述，你可以查看这篇文章：[有意思！强大的 SVG 滤镜](https://github.com/chokcoco/cnblogsArticle/issues/27)

HTML：

```
<div class="fe1">Button</div>
<div class="fe1 hover">Button</div>
<div class="fe2">Button</div>
<div class="fe2 hover">Button</div>
<svg>
    <defs>
        <filter id="fe1">
            <feTurbulence id="animation" type="fractalNoise" baseFrequency="0.00001 9.9999999" numOctaves="1" result="warp">
                <animate attributeName="baseFrequency" from="0.00001 9.9999" to="0.00001 0.001" dur="2s" repeatCount="indefinite"/>
            </feTurbulence>
            <feOffset dx="-90" dy="-90" result="warpOffset"></feOffset>
            <feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="30" in="SourceGraphic" in2="warpOffset"></feDisplacementMap>
        </filter>
        <filter id="fe2">
            <feTurbulence id="animation" type="fractalNoise" baseFrequency="9.9999999 0.00001" numOctaves="1" result="warp">
                <animate attributeName="baseFrequency" from="9.9999999 0.00001" to="0.009 0.00001" dur="2s" repeatCount="indefinite"/>
            </feTurbulence>
            <feOffset dx="-90" dy="-90" result="warpOffset"></feOffset>
            <feDisplacementMap xChannelSelector="R" yChannelSelector="G" scale="30" in="SourceGraphic" in2="warpOffset"></feDisplacementMap>
        </filter>
    </defs>
</svg>
```

SCSS：

```scss
body, html {
    width: 100%;
    height: 100%;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    align-items: center;
}

div {
    width: 200px;
    height: 64px;
    margin: 10px;
    line-height: 64px;
    font-size: 18px;
    color: #fff;
    text-align: center;
    background: #673ab7;
    cursor: pointer;
    transform: translateZ(0);
    outline: 200px solid transparent;
    // filter: url(#filter-turbulence);
}

.fe1:hover {
    filter: url(#fe1);
}

.fe2 {
    border-radius: 64px;
}

.fe2:hover {
    filter: url(#fe2);
}

.fe1.hover {
    filter: url(#fe1);
}
.fe2.hover {
    filter: url(#fe2);
}

svg {
    position: absolute;
}
```

## SVG feTurbulence 滤镜实现云彩效果

使用 SVG feTurbulence 滤镜实现云彩效果 。

### 关键点

SVG `<feTurbulence>` 滤镜能够实现半透明的烟熏或波状图像。 通常用于实现一些特殊的纹理。本效果通过 `<feTurbulence>` 融合颜色背景，模拟云彩效果。

关于本效果的详细描述，你可以查看这篇文章：[有意思！强大的 SVG 滤镜](https://github.com/chokcoco/cnblogsArticle/issues/27)

HTML：

```
<div id="cloud"></div>

<svg width="0">
  <filter id="filter">
    <feTurbulence type="fractalNoise" baseFrequency=".01" numOctaves="10" />
    <feDisplacementMap in="SourceGraphic" scale="240" />
  </filter>
</svg>
```

SCSS：

```scss
html, body { 
  margin: 0; 
}
body:after {
  content: 'click to update';
  font-size: .8em;
  color: rgba(0, 0, 0, .3);
  position: fixed;
  width: 100%;
  bottom: 1em;
  text-align: center;
}

#cloud {
  overflow: hidden;
  width: 1px; height: 1px;
  transform: translate(-100%, -100%);
  border-radius: 50%;
  filter: url(#filter);
}
```

## SVG 文字 hover 线条动画 2

SVG 文字 hover 线条动画

### 关键点

使用了 `stroke-dasharray` 和 `stroke-dashoffset` 控制线条动画。

具体的可以看看我的这篇文章：

[【Web动画】SVG 线条动画入门](https://www.cnblogs.com/coco1s/p/6225973.html)

HTML：

```html
<svg viewBox="0 0 800 600">
  <symbol id="s-text">
    <text text-anchor="middle" x="50%" y="35%" class="text--line" >Swing</text>
    <text text-anchor="middle" x="50%" y="68%" class="text--line2">Text</text>
  </symbol>
  <g class="g-ants">
    <use xlink:href="#s-text" class="text-copy"></use>
    <use xlink:href="#s-text" class="text-copy"></use>
    <use xlink:href="#s-text" class="text-copy"></use>
    <use xlink:href="#s-text" class="text-copy"></use>
    <use xlink:href="#s-text" class="text-copy"></use>
  </g>
</svg>
```

SCSS：

```scss
.text--line {
  font-size: .5em;
}

svg {
  position: absolute;
  width: 100%;
  height: 100%;
}

.text-copy {
  fill: none;
  stroke: white;
  stroke-dasharray: 7% 28%;
  stroke-width: 3px;
  -webkit-animation: stroke-offset 9s infinite linear;
          animation: stroke-offset 9s infinite linear;
}
.text-copy:nth-child(1) {
  stroke: #360745;
  stroke-dashoffset: 7%;
}
.text-copy:nth-child(2) {
  stroke: #D61C59;
  stroke-dashoffset: 14%;
}
.text-copy:nth-child(3) {
  stroke: #E7D84B;
  stroke-dashoffset: 21%;
}
.text-copy:nth-child(4) {
  stroke: #EFEAC5;
  stroke-dashoffset: 28%;
}
.text-copy:nth-child(5) {
  stroke: #1B8798;
  stroke-dashoffset: 35%;
}

@-webkit-keyframes stroke-offset {
  50% {
    stroke-dashoffset: 35%;
    stroke-dasharray: 0 87.5%;
  }
}

@keyframes stroke-offset {
  50% {
    stroke-dashoffset: 35%;
    stroke-dasharray: 0 87.5%;
  }
}
```

## SVG 文字 hover 线条动画

SVG 文字 hover 线条动画。

### 关键点

使用了 `stroke-dasharray` 和 `stroke-dashoffset` 控制线条动画。

具体的可以看看我的这篇文章：

[【Web动画】SVG 线条动画入门](https://www.cnblogs.com/coco1s/p/6225973.html)

HTML：

```html
<svg viewBox="0 0 400 200">
    <text x="0" y="70%"> Lorem </text>
</svg>    
```

SCSS：

```scss
svg {
    width: 600px;
    height: 300px;
    margin: auto;
}

svg text {
    text-transform: uppercase;
    animation: stroke 5s infinite alternate;
    letter-spacing: 10px;
    font-size: 150px;
}
@keyframes stroke {
    0% {
        fill: rgba(72, 138, 20, 0);
        stroke: rgba(54, 95, 160, 1);
        stroke-dashoffset: 25%;
        stroke-dasharray: 0 50%;
        stroke-width: 0.2;
    }
    50% {
        fill: rgba(72, 138, 20, 0);
        stroke: rgba(54, 95, 160, 1);
        stroke-width: 0.5;
    }
    70% {
        fill: rgba(72, 138, 20, 0);
        stroke: rgba(54, 95, 160, 1);
        stroke-width: 1;
    }
    90%,
    100% {
        fill: rgba(72, 138, 204, 1);
        stroke: rgba(54, 95, 160, 0);
        stroke-dashoffset: -25%;
        stroke-dasharray: 50% 0;
        stroke-width: 0;
    }
}
```